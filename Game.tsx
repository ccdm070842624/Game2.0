Total files: 13

===================================================

## File: /db/types.d.ts
```
/**
 * This file was generated by kysely-codegen.
 * DO NOT EDIT THIS FILE DIRECTLY. IT IS AUTO-GENERATED.
 * YOU CAN MODIFY THE DATABASE SCHEMA INSTEAD WITH THE POSTGRESQL TOOLS TO AUTOMATICALLY CHANGE THIS FILE.
 */

export interface DB {}

```

## File: /src/app/_layout.tsx
```
import { Stack } from 'expo-router';
import React from 'react';
import { HeroProvider } from '../context/HeroContext';
import { CommunityProvider } from '../context/CommunityContext';

export default function RootLayout() {
  return (
    <HeroProvider>
      <CommunityProvider>
        <Stack screenOptions={{ headerShown: false }} />
      </CommunityProvider>
    </HeroProvider>
  );
}

```

## File: /src/app/(tabs)/_layout.tsx
```
import { Tabs } from 'expo-router';
import React from 'react';
import Ionicons from '@expo/vector-icons/Ionicons';

export default function TabsLayout() {
  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarActiveTintColor: '#38bdf8',
        tabBarInactiveTintColor: '#94a3b8',
        tabBarStyle: {
          backgroundColor: '#0f172a',
          borderTopColor: '#1e293b',
        },
      }}
    >
      <Tabs.Screen
        name="adventure"
        options={{
          title: 'Путешествие',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="compass" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="camp"
        options={{
          title: 'Лагерь',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="bonfire" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="shop"
        options={{
          title: 'Магазин',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="pricetag" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="community"
        options={{
          title: 'Сообщество',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="people" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="quests"
        options={{
          title: 'Задания',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="list" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

```

## File: /src/app/(tabs)/adventure.tsx
```
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { Image, Pressable, ScrollView, Text, View } from 'react-native';
import Ionicons from '@expo/vector-icons/Ionicons';
import { useHero } from '../../context/HeroContext';
import type {
  DailyGoal,
  HeroStyleAccent,
  InventoryItem,
  TravelDifficulty,
} from '../../context/HeroContext';
import { SegmentedProgress } from '../../components/SegmentedProgress';
import { accentPalette } from '../../utils/accent';

type EncounterType = 'battle' | 'event' | 'treasure';

type EncounterElement = 'frost' | 'ember' | 'shadow' | 'storm';

interface Encounter {
  id: string;
  name: string;
  description: string;
  type: EncounterType;
  difficulty: number;
  element: EncounterElement;
  rewardHint: string;
}

const accentDescription: Record<HeroStyleAccent, string> = {
  emerald: 'Нити природы наполняют клинок гармонией.',
  sky: 'Штормовые сполохи следуют за каждым шагом.',
  violet: 'Скрытная тень сопровождает движение.',
  amber: 'Жар костров дарит стойкость и тепло.',
  crimson: 'Алые искры готовят героя к битве.',
};

const heroArtwork: Record<HeroStyleAccent, string> = {
  emerald:
    'https://a.asim.sh/images?query=fantasy+heroine+emerald+armor+dynamic+pose+magic+aura',
  sky: 'https://a.asim.sh/images?query=fantasy+mage+blue+arcane+energy+beautiful+illustration',
  violet:
    'https://a.asim.sh/images?query=fantasy+assassin+violet+robes+ethereal+glow+transparent+background',
  amber:
    'https://a.asim.sh/images?query=fantasy+warrior+amber+flames+stylized+portrait',
  crimson:
    'https://a.asim.sh/images?query=fantasy+knight+crimson+cloak+dramatic+lighting+transparent+background',
};

const difficultySettings: Record<
  TravelDifficulty,
  {
    label: string;
    description: string;
    xp: number;
    coins: number;
    damage: number;
  }
> = {
  story: {
    label: 'История',
    description: 'Умеренный риск и классические награды.',
    xp: 1,
    coins: 1,
    damage: 1,
  },
  adventure: {
    label: 'Приключение',
    description: 'Повышенные награды за небольшой рост опасности.',
    xp: 1.15,
    coins: 1.1,
    damage: 1.05,
  },
  mythic: {
    label: 'Мифический',
    description: 'Героический вызов с легендарными трофеями.',
    xp: 1.35,
    coins: 1.25,
    damage: 1.2,
  },
};

const expeditionPlans: Array<{
  id: string;
  title: string;
  description: string;
  steps: EncounterType[];
  icon: keyof typeof Ionicons.glyphMap;
}> = [
  {
    id: 'swift_assault',
    title: 'Штурмовая вылазка',
    description: 'Две схватки и поиск сокровища.',
    steps: ['battle', 'battle', 'treasure'],
    icon: 'flame',
  },
  {
    id: 'arcane_research',
    title: 'Арканные исследования',
    description: 'Событие, затем битва и ещё одно событие.',
    steps: ['event', 'battle', 'event'],
    icon: 'flask',
  },
  {
    id: 'scout_route',
    title: 'Разведка тропы',
    description: 'Сундук, событие и лёгкая схватка.',
    steps: ['treasure', 'event', 'battle'],
    icon: 'compass',
  },
];

const encounterNames: Record<EncounterType, string[]> = {
  battle: ['Теневой волк', 'Пепельный голем', 'Фантом ветра', 'Страж руин'],
  event: [
    'Дух перелеска',
    'Тайный алтарь',
    'Колдун-отшельник',
    'Голос древности',
  ],
  treasure: [
    'Забытый сундук',
    'Светящийся кокон',
    'Алхимический набор',
    'Кристальный монолит',
  ],
};

const encounterDescriptions: Record<EncounterType, string[]> = {
  battle: [
    'Порождение тьмы выходит из зарослей, замахиваясь когтями, пропитанными эфиром.',
    'Магическая конструкция пробуждается, её руны мерцают холодным огнём.',
    'Порыв ледяного ветра собирается в призрачный силуэт, готовясь к атаке.',
    'Из-под земли поднимается древний страж, чьи глаза вспыхивают багровым светом.',
  ],
  event: [
    'Вы чувствуете переливчатое присутствие. Оно ждет решение, достойное сердца героя.',
    'Перед вами алтарь: его руны мерцают, приглашая вложить часть своей сущности.',
    'На пути появляется странник, предлагающий обменять знания на крупицу силы.',
    'Шепоты древних обещают дар, если вы проявите смелость и терпение.',
  ],
  treasure: [
    'На каменистом уступе скрыт сундук. Его замок усеян магическими символами.',
    'Под корнями величественного дуба сияет кокон с кристаллами эфирного света.',
    'Алхимический прибор, оставленный мастером, ещё теплится энергией.',
    'Перед вами монолит, наполненный звенящим светом. Возможно, он скрывает артефакт.',
  ],
};

const elementsColors: Record<EncounterElement, string> = {
  frost: 'text-sky-400',
  ember: 'text-amber-400',
  shadow: 'text-fuchsia-400',
  storm: 'text-emerald-400',
};

const rewardHints: Record<EncounterType, string[]> = {
  battle: ['Опыт и трофеи', 'Трофеи охотника', 'Осколки силы', 'Знак отваги'],
  event: ['Дар судьбы', 'Испытание духа', 'Урок мудреца', 'Эхо легенд'],
  treasure: [
    'Заметная находка',
    'Алхимическая добыча',
    'Арканный эликсир',
    'Нечто редкое',
  ],
};

const encounterDisplay: Record<EncounterType, string> = {
  battle: 'Битва',
  event: 'Событие',
  treasure: 'Сокровище',
};

const elementLabels: Record<EncounterElement, string> = {
  frost: 'Ледяная стихия',
  ember: 'Пепельная стихия',
  shadow: 'Теневой поток',
  storm: 'Штормовой эфир',
};

const lootPool: Record<InventoryItem['rarity'], InventoryItem[]> = {
  common: [
    {
      id: 'worn_charm',
      name: 'Потускневший талисман',
      rarity: 'common',
      type: 'artifact',
      description: 'Слабый оберег, слегка усиливающий выживание.',
      value: 18,
      quantity: 1,
    },
    {
      id: 'windrunner_wrap',
      name: 'Накидка бегущего по ветру',
      rarity: 'common',
      type: 'outfit',
      description: 'Простой плащ, добавляющий легкости движениям.',
      value: 28,
      quantity: 1,
      bonuses: {
        agility: 1,
      },
    },
    {
      id: 'herbal_draught',
      name: 'Травяной настой',
      rarity: 'common',
      type: 'consumable',
      description: 'Напиток травницы из Лориэля. Восстанавливает 24 здоровья.',
      value: 14,
      quantity: 1,
      stackable: true,
      effect: {
        type: 'heal',
        value: 24,
      },
    },
  ],
  uncommon: [
    {
      id: 'sylvan_blade',
      name: 'Клинок силванов',
      rarity: 'uncommon',
      type: 'weapon',
      description: 'Изящное оружие лесных стражей, добавляет точность ударов.',
      value: 52,
      quantity: 1,
      bonuses: {
        attack: 3,
      },
    },
    {
      id: 'glowthread_vest',
      name: 'Сияющий жилет',
      rarity: 'uncommon',
      type: 'armor',
      description:
        'Лёгкая броня, вплетающая светлую магию для дополнительной защиты.',
      value: 60,
      quantity: 1,
      bonuses: {
        defense: 2,
        maxHp: 6,
      },
    },
    {
      id: 'mana_wafer',
      name: 'Эфирная пластина',
      rarity: 'uncommon',
      type: 'consumable',
      description: 'Энергетическое лакомство, восстанавливающее 30 маны.',
      value: 40,
      quantity: 1,
      stackable: true,
      effect: {
        type: 'mana',
        value: 30,
      },
    },
  ],
  rare: [
    {
      id: 'arcane_vial',
      name: 'Фиал арканного прилива',
      rarity: 'rare',
      type: 'consumable',
      description: 'Выплеск чистой маны. Восстанавливает 45 единиц.',
      value: 70,
      quantity: 1,
      stackable: true,
      effect: {
        type: 'mana',
        value: 45,
      },
    },
    {
      id: 'stormstep_boots',
      name: 'Башмаки штормового шага',
      rarity: 'rare',
      type: 'outfit',
      description: 'Обувь, заряженная громовыми рунами, увеличивает ловкость.',
      value: 120,
      quantity: 1,
      bonuses: {
        agility: 3,
        attack: 1,
      },
    },
    {
      id: 'luminous_band',
      name: 'Световой обруч',
      rarity: 'rare',
      type: 'accessory',
      description: 'Украшение, усиливающее поток маны и внимательность.',
      value: 130,
      quantity: 1,
      bonuses: {
        maxMana: 10,
        agility: 1,
      },
    },
  ],
  epic: [
    {
      id: 'crown_of_tempest',
      name: 'Корона бури',
      rarity: 'epic',
      type: 'artifact',
      description:
        'Редкий артефакт, наполняющий носителя неистовством штормов.',
      value: 180,
      quantity: 1,
      bonuses: {
        attack: 4,
        maxMana: 8,
      },
    },
    {
      id: 'veil_of_dusk',
      name: 'Покров сумрака',
      rarity: 'epic',
      type: 'outfit',
      description: 'Редкая накидка, делающая движения почти бесшумными.',
      value: 200,
      quantity: 1,
      bonuses: {
        agility: 4,
        defense: 2,
      },
    },
    {
      id: 'ember_signet',
      name: 'Перстень огненного потока',
      rarity: 'epic',
      type: 'accessory',
      description: 'Кольцо, усиливающее как ману, так и силу удара.',
      value: 210,
      quantity: 1,
      bonuses: {
        attack: 2,
        maxMana: 12,
      },
    },
  ],
  legendary: [
    {
      id: 'heart_of_auren',
      name: 'Сердце Аурена',
      rarity: 'legendary',
      type: 'artifact',
      description: 'Мифический кристалл, усиливающий все аспекты героя.',
      value: 320,
      quantity: 1,
      bonuses: {
        attack: 3,
        defense: 3,
        maxHp: 18,
      },
    },
    {
      id: 'astral_regalia',
      name: 'Астральное облачение',
      rarity: 'legendary',
      type: 'outfit',
      description: 'Целый комплект одежды, сотканный из звездного света.',
      value: 340,
      quantity: 1,
      bonuses: {
        agility: 4,
        maxMana: 16,
      },
    },
    {
      id: 'guardian_plate',
      name: 'Доспех хранителя',
      rarity: 'legendary',
      type: 'armor',
      description: 'Массивная броня, защищающая от тяжёлых ударов.',
      value: 360,
      quantity: 1,
      bonuses: {
        defense: 6,
        maxHp: 20,
      },
    },
  ],
};

const copyLootItem = (item: InventoryItem): InventoryItem => {
  const unique = !(item.stackable ?? false);
  const id = unique
    ? `${item.id}_${Math.random().toString(16).slice(2, 8)}`
    : item.id;
  return {
    ...item,
    id,
    effect: item.effect ? { ...item.effect } : undefined,
    bonuses: item.bonuses ? { ...item.bonuses } : undefined,
  };
};

const randomFrom = <T,>(items: T[]): T =>
  items[Math.floor(Math.random() * items.length)];

const createEncounter = (type: EncounterType, index: number): Encounter => {
  const element: EncounterElement = randomFrom([
    'frost',
    'ember',
    'shadow',
    'storm',
  ]);
  return {
    id: `${type}-${Date.now()}-${index}-${Math.random().toString(16).slice(2, 6)}`,
    type,
    element,
    difficulty: Math.floor(Math.random() * 3) + 1,
    name: randomFrom(encounterNames[type]),
    description: randomFrom(encounterDescriptions[type]),
    rewardHint: randomFrom(rewardHints[type]),
  };
};

const createLoot = (rarity: InventoryItem['rarity']): InventoryItem => {
  const pool = lootPool[rarity];
  const template = randomFrom(pool);
  return copyLootItem(template);
};

const getRarityByDifficulty = (difficulty: number): InventoryItem['rarity'] => {
  if (difficulty >= 4) return 'epic';
  if (difficulty === 3) return 'rare';
  if (difficulty === 2) return 'uncommon';
  return 'common';
};

const getXpReward = (type: EncounterType, difficulty: number) => {
  const base = type === 'battle' ? 60 : type === 'event' ? 45 : 35;
  return base + difficulty * 18 + Math.round(Math.random() * 12);
};

const getCoinReward = (type: EncounterType, difficulty: number) => {
  const base = type === 'battle' ? 28 : type === 'event' ? 18 : 35;
  return base + difficulty * 12 + Math.round(Math.random() * 10);
};

const getDamageRange = (difficulty: number) => {
  const min = difficulty * 6 + 4;
  const max = difficulty * 12 + 10;
  return [min, max];
};

const clamp = (value: number, min: number, max: number) =>
  Math.max(min, Math.min(max, value));

const MAX_LOG_ENTRIES = 10;

const formatLogMessage = (message: string) =>
  `${new Date().toLocaleTimeString()} · ${message}`;

export default function AdventureScreen() {
  const {
    state,
    isLoaded,
    gainXp,
    takeDamage,
    restoreHealth,
    spendMana,
    restoreMana,
    addInventoryItem,
    earnCoins,
    advanceQuest,
    revive,
    setTravelDifficulty,
    updateDailyGoal,
    trackHeroStat,
    claimDailyGoal,
  } = useHero();

  const [encounters, setEncounters] = useState<Encounter[]>([]);
  const [adventureLog, setAdventureLog] = useState<string[]>([]);
  const [isExploring, setIsExploring] = useState(false);
  const [isPlanning, setIsPlanning] = useState(false);

  const accent = useMemo(
    () => accentPalette[state.styleAccent],
    [state.styleAccent],
  );
  const heroArt = useMemo(
    () => heroArtwork[state.styleAccent],
    [state.styleAccent],
  );
  const difficultyProfile = useMemo(
    () => difficultySettings[state.travelDifficulty],
    [state.travelDifficulty],
  );
  const dailyGoals = useMemo<DailyGoal[]>(
    () => state.dailyGoals,
    [state.dailyGoals],
  );

  const appendLog = useCallback((entry: string) => {
    setAdventureLog((prev) =>
      [formatLogMessage(entry), ...prev].slice(0, MAX_LOG_ENTRIES),
    );
  }, []);

  const rollEncounters = useCallback(() => {
    const options: Encounter[] = [
      createEncounter('battle', 0),
      createEncounter('event', 1),
      createEncounter('treasure', 2),
    ];
    setEncounters(options);
  }, []);

  useEffect(() => {
    if (isLoaded) {
      rollEncounters();
    }
  }, [isLoaded, rollEncounters]);

  const handleBattle = useCallback(
    (encounter: Encounter) => {
      const [minDamage, maxDamage] = getDamageRange(encounter.difficulty);
      const enemyPower = clamp(
        Math.round(Math.random() * maxDamage) + minDamage,
        minDamage,
        maxDamage,
      );
      const mitigated = Math.max(
        0,
        enemyPower - Math.round(state.defense * 0.65),
      );
      const baseDamage = clamp(mitigated, 8, enemyPower);
      const finalDamage = Math.max(
        0,
        Math.round(baseDamage * difficultyProfile.damage),
      );
      const remainingHp = Math.max(0, state.hp - finalDamage);
      takeDamage(finalDamage);
      appendLog(
        `Схватка с ${encounter.name}. Получено ${finalDamage} урона (${difficultyProfile.label}).`,
      );
      if (remainingHp <= 0) {
        appendLog(
          'Вы пали в бою, но эфир бережно возвращает вас к жизни. Часть монет потеряна.',
        );
        revive();
        rollEncounters();
        return;
      }
      const xpReward = Math.max(
        1,
        Math.round(
          getXpReward(encounter.type, encounter.difficulty + 1) *
            difficultyProfile.xp,
        ),
      );
      const coinReward = Math.max(
        1,
        Math.round(
          getCoinReward('battle', encounter.difficulty + 1) *
            difficultyProfile.coins,
        ),
      );
      gainXp(xpReward);
      earnCoins(coinReward);
      advanceQuest('battle', 1);
      updateDailyGoal('battle', 1);
      trackHeroStat({ battlesWon: 1 });
      appendLog(
        `Победа! Получено ${xpReward} опыта и ${coinReward} монет (${difficultyProfile.label}).`,
      );
      if (Math.random() > 0.45) {
        const rarity = getRarityByDifficulty(
          encounter.difficulty + (Math.random() > 0.8 ? 1 : 0),
        );
        const loot = createLoot(rarity);
        addInventoryItem({ ...loot });
        if (loot.type === 'outfit' || loot.type === 'accessory') {
          advanceQuest('style', 1);
        }
        if (loot.type === 'weapon' || loot.type === 'armor') {
          advanceQuest('gear', 1);
        }
        appendLog(`Трофей: ${loot.name} (${loot.rarity}).`);
      }
      rollEncounters();
    },
    [
      advanceQuest,
      addInventoryItem,
      appendLog,
      difficultyProfile,
      earnCoins,
      gainXp,
      revive,
      rollEncounters,
      state.defense,
      state.hp,
      takeDamage,
      trackHeroStat,
      updateDailyGoal,
    ],
  );

  const handleEvent = useCallback(
    (encounter: Encounter) => {
      const choice = Math.random();
      if (choice < 0.25) {
        const manaCost = 18;
        const canSpend = spendMana(manaCost);
        if (canSpend) {
          const xpReward = Math.max(
            1,
            Math.round(
              getXpReward('event', encounter.difficulty) * difficultyProfile.xp,
            ),
          );
          gainXp(xpReward);
          advanceQuest('lore', 1);
          updateDailyGoal('explore', 1);
          trackHeroStat({ eventsCompleted: 1 });
          appendLog(
            `Вы вложили ${manaCost} маны в ${encounter.name} и получили ${xpReward} опыта.`,
          );
        } else {
          appendLog(
            'Слишком мало маны для взаимодействия с загадочным явлением.',
          );
        }
      } else if (choice < 0.6) {
        const healValue = 22 + encounter.difficulty * 6;
        restoreHealth(healValue);
        updateDailyGoal('explore', 1);
        trackHeroStat({ eventsCompleted: 1 });
        appendLog(`${encounter.name} исцеляет ${healValue} здоровья.`);
      } else {
        const manaValue = 18 + encounter.difficulty * 4;
        restoreMana(manaValue);
        updateDailyGoal('explore', 1);
        trackHeroStat({ eventsCompleted: 1 });
        appendLog(`${encounter.name} наполняет ${manaValue} маны.`);
      }
      rollEncounters();
    },
    [
      advanceQuest,
      appendLog,
      difficultyProfile,
      gainXp,
      restoreHealth,
      restoreMana,
      rollEncounters,
      spendMana,
      trackHeroStat,
      updateDailyGoal,
    ],
  );

  const handleTreasure = useCallback(
    (encounter: Encounter) => {
      const coins = Math.max(
        1,
        Math.round(
          getCoinReward('treasure', encounter.difficulty) *
            difficultyProfile.coins,
        ),
      );
      earnCoins(coins);
      updateDailyGoal('explore', 1);
      trackHeroStat({ treasuresOpened: 1 });
      appendLog(`Найдено ${coins} монет. ${encounter.rewardHint}.`);
      if (Math.random() > 0.35) {
        const rarityChance = Math.random();
        let rarity: InventoryItem['rarity'] = 'common';
        if (rarityChance > 0.85) rarity = 'rare';
        else if (rarityChance > 0.65) rarity = 'uncommon';
        if (rarityChance > 0.95) rarity = 'epic';
        const loot = createLoot(rarity);
        if (loot.type === 'consumable') {
          loot.stackable = true;
        }
        addInventoryItem({ ...loot });
        if (loot.type === 'outfit' || loot.type === 'accessory') {
          advanceQuest('style', 1);
        }
        if (loot.type === 'weapon' || loot.type === 'armor') {
          advanceQuest('gear', 1);
        }
        appendLog(`Вы обнаружили: ${loot.name}.`);
      }
      advanceQuest('explore', 1);
      rollEncounters();
    },
    [
      addInventoryItem,
      advanceQuest,
      appendLog,
      difficultyProfile,
      earnCoins,
      rollEncounters,
      trackHeroStat,
      updateDailyGoal,
    ],
  );

  const runExpeditionPlan = useCallback(
    (planId: string) => {
      if (isExploring || isPlanning) {
        return;
      }
      const plan = expeditionPlans.find((option) => option.id === planId);
      if (!plan) {
        return;
      }
      setIsPlanning(true);
      appendLog(`Вы готовите план: ${plan.title}.`);
      plan.steps.forEach((step, index) => {
        const delay = 420 * (index + 1);
        setTimeout(() => {
          const generatedEncounter = createEncounter(step, index);
          if (step === 'battle') {
            handleBattle(generatedEncounter);
          } else if (step === 'event') {
            handleEvent(generatedEncounter);
          } else {
            handleTreasure(generatedEncounter);
          }
          if (index === plan.steps.length - 1) {
            setIsPlanning(false);
          }
        }, delay);
      });
    },
    [
      appendLog,
      handleBattle,
      handleEvent,
      handleTreasure,
      isExploring,
      isPlanning,
    ],
  );

  const onEncounterPress = useCallback(
    (encounter: Encounter) => {
      if (isExploring || isPlanning) {
        return;
      }
      setIsExploring(true);

      setTimeout(() => {
        if (encounter.type === 'battle') {
          handleBattle(encounter);
        } else if (encounter.type === 'event') {
          handleEvent(encounter);
        } else {
          handleTreasure(encounter);
        }
        setIsExploring(false);
      }, 320);
    },
    [handleBattle, handleEvent, handleTreasure, isExploring, isPlanning],
  );

  const handleRefresh = useCallback(() => {
    if (isExploring || isPlanning) {
      return;
    }
    appendLog(
      'Вы внимательно осматриваете окрестности в поисках новых возможностей...',
    );
    rollEncounters();
  }, [appendLog, isExploring, isPlanning, rollEncounters]);

  if (!isLoaded) {
    return (
      <View className="flex-1 items-center justify-center bg-slate-950">
        <Text className="text-slate-200 text-lg">
          Тайны мира загружаются...
        </Text>
      </View>
    );
  }

  return (
    <View className="flex-1 bg-slate-950">
      <ScrollView className="flex-1">
        <View className="px-5 pt-12">
          <Text className="text-slate-300 text-xs uppercase tracking-[3px]">
            Путевые хроники
          </Text>
          <Text className="text-slate-200 mt-2 text-3xl font-semibold">
            {state.name}
          </Text>
          <Text className="text-slate-500 mt-1 text-base">
            {state.archetype} · Уровень {state.level}
          </Text>
        </View>

        <View className="px-5 mt-5">
          <View
            className={`rounded-3xl border ${accent.border} ${accent.surface} px-5 py-4 ${accent.glow}`}
          >
            <View className="flex-row items-center">
              <View className="flex-1">
                <Text className="text-slate-200 text-base font-semibold">
                  Актуальный образ
                </Text>
                <Text className={`${accent.text} mt-1 text-sm`}>
                  {accentDescription[state.styleAccent]}
                </Text>
                <View className="mt-3">
                  <View className="flex-row">
                    <View className="mr-4">
                      <Text className="text-slate-400 text-xs uppercase">
                        Оружие
                      </Text>
                      <Text className="text-slate-200 mt-1 text-sm font-semibold">
                        {state.equipment.weapon?.name ?? 'Не выбрано'}
                      </Text>
                    </View>
                    <View className="mr-4">
                      <Text className="text-slate-400 text-xs uppercase">
                        Наряд
                      </Text>
                      <Text className="text-slate-200 mt-1 text-sm font-semibold">
                        {state.equipment.outfit?.name ?? 'Не выбран'}
                      </Text>
                    </View>
                    <View>
                      <Text className="text-slate-400 text-xs uppercase">
                        Аксессуар
                      </Text>
                      <Text className="text-slate-200 mt-1 text-sm font-semibold">
                        {state.equipment.accessory?.name ?? '—'}
                      </Text>
                    </View>
                  </View>
                </View>
              </View>
              <View className="ml-4 h-24 w-24 overflow-hidden rounded-3xl bg-slate-900/60">
                <Image
                  source={{ uri: heroArt }}
                  className="h-full w-full"
                  resizeMode="cover"
                />
              </View>
            </View>
          </View>
        </View>

        <View className="px-5 mt-4">
          <Text className="text-slate-200 text-xl font-semibold">
            Режим путешествия
          </Text>
          <Text className="text-slate-500 mt-1">
            {difficultyProfile.description}
          </Text>
          <View className="mt-3 flex-row flex-wrap">
            {(Object.keys(difficultySettings) as TravelDifficulty[]).map(
              (key) => {
                const option = difficultySettings[key];
                const isActive = state.travelDifficulty === key;
                return (
                  <Pressable
                    key={key}
                    onPress={() => setTravelDifficulty(key)}
                    disabled={isActive}
                    className={`mr-3 mb-3 rounded-2xl border px-4 py-2 ${
                      isActive
                        ? `${accent.border} ${accent.surface}`
                        : 'border-slate-700/60 bg-slate-900/80'
                    }`}
                  >
                    <Text className="text-slate-200 text-sm font-semibold">
                      {option.label}
                    </Text>
                  </Pressable>
                );
              },
            )}
          </View>
        </View>

        <View className="px-5 mt-6">
          <View className="rounded-3xl border border-slate-700/60 bg-slate-900/80 p-5">
            <Text className="text-slate-300 text-sm uppercase tracking-widest">
              Показатели
            </Text>
            <View className="mt-4">
              <View>
                <View className="flex-row items-center justify-between">
                  <Text className="text-slate-200 font-semibold">Здоровье</Text>
                  <Text className="text-emerald-400 font-semibold">
                    {state.hp}/{state.maxHp}
                  </Text>
                </View>
                <SegmentedProgress
                  value={state.hp}
                  max={state.maxHp}
                  filledClassName="bg-emerald-500"
                />
              </View>
              <View className="mt-4">
                <View className="flex-row items-center justify-between">
                  <Text className="text-slate-200 font-semibold">Мана</Text>
                  <Text className="text-sky-400 font-semibold">
                    {state.mana}/{state.maxMana}
                  </Text>
                </View>
                <SegmentedProgress
                  value={state.mana}
                  max={state.maxMana}
                  filledClassName="bg-sky-500"
                />
              </View>
              <View className="mt-4">
                <View className="flex-row items-center justify-between">
                  <Text className="text-slate-200 font-semibold">Опыт</Text>
                  <Text className="text-indigo-400 font-semibold">
                    {state.xp}/{state.xpForNext}
                  </Text>
                </View>
                <SegmentedProgress
                  value={state.xp}
                  max={state.xpForNext}
                  filledClassName="bg-indigo-500"
                />
              </View>
            </View>
            <View className="mt-6 flex-row">
              <View className="mr-5">
                <Text className="text-slate-500 text-xs uppercase">Атака</Text>
                <Text className="text-slate-200 text-lg font-semibold">
                  {state.attack}
                </Text>
              </View>
              <View className="mr-5">
                <Text className="text-slate-500 text-xs uppercase">Защита</Text>
                <Text className="text-slate-200 text-lg font-semibold">
                  {state.defense}
                </Text>
              </View>
              <View className="mr-5">
                <Text className="text-slate-500 text-xs uppercase">
                  Ловкость
                </Text>
                <Text className="text-slate-200 text-lg font-semibold">
                  {state.agility}
                </Text>
              </View>
              <View>
                <Text className="text-slate-500 text-xs uppercase">Монеты</Text>
                <Text className="text-amber-400 text-lg font-semibold">
                  {state.coins}
                </Text>
              </View>
            </View>
          </View>
        </View>

        <View className="px-5 mt-6">
          <Text className="text-slate-200 text-xl font-semibold">
            Ежедневные задачи
          </Text>
          <Text className="text-slate-500 mt-1">
            Выполняйте поручения и получайте небольшие награды.
          </Text>
          {dailyGoals.length === 0 ? (
            <View className="mt-4 rounded-3xl border border-slate-700/60 bg-slate-900/80 p-4">
              <Text className="text-slate-500">
                Ещё нет ежедневных целей. Загляните позже.
              </Text>
            </View>
          ) : (
            dailyGoals.map((goal) => {
              const isReady = goal.completed && !goal.claimed;
              const statusLabel = goal.claimed
                ? 'Награда получена'
                : goal.completed
                  ? 'Готово к выдаче'
                  : 'В процессе';
              return (
                <View
                  key={goal.id}
                  className="mt-4 rounded-3xl border border-slate-700/60 bg-slate-900/80 p-4"
                >
                  <View className="flex-row items-start justify-between">
                    <View className="flex-1 pr-3">
                      <Text className="text-slate-200 text-base font-semibold">
                        {goal.title}
                      </Text>
                      <Text className="text-slate-500 mt-1 text-sm">
                        {goal.description}
                      </Text>
                      <Text className="text-slate-600 mt-2 text-xs uppercase">
                        {statusLabel}
                      </Text>
                    </View>
                    {isReady ? (
                      <Pressable
                        onPress={() => {
                          const result = claimDailyGoal(goal.id);
                          appendLog(result.message);
                        }}
                        className="rounded-2xl bg-emerald-500/20 px-3 py-2"
                      >
                        <Text className="text-emerald-200 text-sm font-semibold">
                          Забрать
                        </Text>
                      </Pressable>
                    ) : (
                      <View className="rounded-2xl bg-slate-800/60 px-3 py-2">
                        <Text className="text-slate-500 text-sm font-semibold">
                          {goal.claimed ? 'Получено' : 'Ожидание'}
                        </Text>
                      </View>
                    )}
                  </View>
                  <View className="mt-3">
                    <SegmentedProgress
                      value={goal.progress}
                      max={goal.goal}
                      filledClassName="bg-emerald-500"
                    />
                    <Text className="text-slate-400 mt-2 text-xs">
                      {goal.progress}/{goal.goal} · Награда {goal.rewardXp}{' '}
                      опыта / {goal.rewardCoins} монет
                    </Text>
                  </View>
                </View>
              );
            })
          )}
        </View>

        <View className="px-5 mt-6">
          <Text className="text-slate-200 text-xl font-semibold">
            Экспедиционные планы
          </Text>
          <Text className="text-slate-500 mt-1">
            Подберите серию действий, чтобы оптимизировать исследования.
          </Text>
          {expeditionPlans.map((plan, index) => {
            const isDisabled = isExploring || isPlanning;
            return (
              <Pressable
                key={plan.id}
                onPress={() => runExpeditionPlan(plan.id)}
                disabled={isDisabled}
                className={`${index === 0 ? 'mt-4' : 'mt-3'} rounded-3xl border border-slate-700/60 bg-slate-900/80 p-4 ${
                  isDisabled ? 'opacity-60' : 'opacity-100'
                }`}
              >
                <View className="flex-row items-start">
                  <View className="h-10 w-10 items-center justify-center rounded-2xl bg-slate-800/70">
                    <Ionicons name={plan.icon} size={20} color={accent.icon} />
                  </View>
                  <View className="ml-4 flex-1">
                    <Text className="text-slate-200 text-base font-semibold">
                      {plan.title}
                    </Text>
                    <Text className="text-slate-500 mt-1 text-sm">
                      {plan.description}
                    </Text>
                    <Text className="text-slate-600 mt-2 text-xs uppercase">
                      {plan.steps
                        .map((step) => encounterDisplay[step])
                        .join(' · ')}
                    </Text>
                  </View>
                </View>
              </Pressable>
            );
          })}
        </View>
        <View className="px-5 mt-8">
          <View className="flex-row items-center justify-between">
            <Text className="text-slate-200 text-xl font-semibold">
              Выбор пути
            </Text>
            <Pressable
              onPress={handleRefresh}
              className="flex-row items-center"
              disabled={isExploring || isPlanning}
            >
              <Ionicons
                name="refresh"
                size={18}
                color={isExploring || isPlanning ? '#64748b' : accent.icon}
              />
              <Text
                className={`ml-1 font-semibold ${
                  isExploring || isPlanning ? 'text-slate-500' : accent.text
                }`}
              >
                Обновить
              </Text>
            </Pressable>
          </View>
          <Text className="text-slate-500 mt-1">
            Мир Эраэлиона живёт собственным дыханием. Выберите направление,
            чтобы соткать новую легенду.
          </Text>
        </View>

        <View className="px-5 mt-5">
          {encounters.map((encounter, index) => (
            <Pressable
              key={encounter.id}
              onPress={() => onEncounterPress(encounter)}
              disabled={isExploring || isPlanning}
              className={`${index === 0 ? 'mt-2' : 'mt-4'} rounded-3xl border border-slate-700/50 bg-slate-900/80 p-5 ${
                isExploring || isPlanning ? 'opacity-60' : 'opacity-100'
              }`}
            >
              <View className="flex-row items-center justify-between">
                <View>
                  <Text className="text-slate-200 text-lg font-semibold">
                    {encounter.name}
                  </Text>
                  <Text className="text-slate-500 mt-1 text-sm">
                    {encounter.description}
                  </Text>
                </View>
                <View className="items-end">
                  <Ionicons
                    name={
                      encounter.type === 'battle'
                        ? 'flame'
                        : encounter.type === 'event'
                          ? 'color-wand'
                          : 'diamond'
                    }
                    size={22}
                    color={accent.icon}
                  />
                  <Text
                    className={`mt-1 text-xs font-semibold ${elementsColors[encounter.element]}`}
                  >
                    {elementLabels[encounter.element]}
                  </Text>
                </View>
              </View>
              <View className="mt-4 flex-row justify-between">
                <Text className="text-slate-500 text-xs uppercase">
                  Сложность · {encounter.difficulty}
                </Text>
                <Text className="text-slate-500 text-xs uppercase">
                  {encounter.rewardHint}
                </Text>
              </View>
            </Pressable>
          ))}
        </View>

        <View className="px-5 mt-8">
          <Text className="text-slate-200 text-xl font-semibold">
            Журнал похода
          </Text>
          <View
            className={`mt-3 rounded-3xl border ${accent.border} bg-slate-900/80 p-5`}
          >
            {adventureLog.length === 0 ? (
              <Text className="text-slate-500">
                Хроники пусты. Выберите путь, чтобы вписать новую строку в
                легенду героя.
              </Text>
            ) : (
              adventureLog.map((entry, index) => (
                <View
                  key={entry}
                  className={
                    index === adventureLog.length - 1 ? 'mb-0' : 'mb-3'
                  }
                >
                  <Text className="text-slate-300 leading-6">{entry}</Text>
                </View>
              ))
            )}
          </View>
        </View>
        <View className="h-16" />
      </ScrollView>
    </View>
  );
}

```

## File: /src/app/(tabs)/camp.tsx
```
import React, { useCallback, useMemo, useRef, useState } from 'react';
import { Image, Pressable, ScrollView, Text, View } from 'react-native';
import Ionicons from '@expo/vector-icons/Ionicons';
import { SegmentedProgress } from '../../components/SegmentedProgress';
import { useHero } from '../../context/HeroContext';
import type {
  AttributeStat,
  EquipmentSlot,
  HeroStyleAccent,
  InventoryItem,
} from '../../context/HeroContext';
import { accentPalette } from '../../utils/accent';

type AttributeOption = {
  key: AttributeStat;
  title: string;
  description: string;
  icon: keyof typeof Ionicons.glyphMap;
  highlight: string;
};

const attributeOptions: AttributeOption[] = [
  {
    key: 'attack',
    title: 'Тактика удара',
    description: 'Увеличивает силу ваших комбинаций в бою.',
    icon: 'flash',
    highlight: 'text-rose-400',
  },
  {
    key: 'defense',
    title: 'Стойкость щита',
    description: 'Снижает получаемый урон и укрепляет броню.',
    icon: 'shield',
    highlight: 'text-emerald-400',
  },
  {
    key: 'agility',
    title: 'Ритм клинка',
    description: 'Повышает уклонение и скорость ответных ударов.',
    icon: 'speedometer',
    highlight: 'text-sky-400',
  },
  {
    key: 'maxHp',
    title: 'Закал души',
    description: 'Расширяет предел жизненной силы героя.',
    icon: 'heart',
    highlight: 'text-amber-400',
  },
  {
    key: 'maxMana',
    title: 'Арканный резерв',
    description: 'Увеличивает запас маны для сложных ритуалов.',
    icon: 'water',
    highlight: 'text-indigo-400',
  },
];

const rarityColors: Record<InventoryItem['rarity'], string> = {
  common: 'text-slate-400',
  uncommon: 'text-emerald-400',
  rare: 'text-sky-400',
  epic: 'text-violet-400',
  legendary: 'text-amber-400',
};

const accentOptions: Array<{
  key: HeroStyleAccent;
  title: string;
  description: string;
}> = [
  {
    key: 'emerald',
    title: 'Изумрудные ветры',
    description: 'Природный блеск, подчёркивающий друидическую грацию.',
  },
  {
    key: 'sky',
    title: 'Небесная вспышка',
    description: 'Холодное сияние для магов и проводников бурь.',
  },
  {
    key: 'violet',
    title: 'Аметистовый шёлк',
    description: 'Тон магических ночей и скрытой мощи.',
  },
  {
    key: 'amber',
    title: 'Янтарное пламя',
    description: 'Тепло костров и огненных ритуалов.',
  },
  {
    key: 'crimson',
    title: 'Алый авангард',
    description: 'Ярость воина, бросающего вызов тьме.',
  },
];

const accentIllustrations: Record<HeroStyleAccent, string> = {
  emerald:
    'https://a.asim.sh/images?query=fantasy+campfire+emerald+glow+hero+art',
  sky: 'https://a.asim.sh/images?query=fantasy+mage+camp+blue+magic+illustration',
  violet:
    'https://a.asim.sh/images?query=fantasy+assassin+camp+violet+lantern+art',
  amber: 'https://a.asim.sh/images?query=fantasy+warrior+campfire+amber+tones',
  crimson:
    'https://a.asim.sh/images?query=fantasy+knight+crimson+camp+dramatic+lighting',
};

const equipmentSlots: Array<{
  key: EquipmentSlot;
  label: string;
  icon: keyof typeof Ionicons.glyphMap;
}> = [
  { key: 'weapon', label: 'Оружие', icon: 'flash' },
  { key: 'armor', label: 'Доспех', icon: 'shield' },
  { key: 'outfit', label: 'Наряд', icon: 'shirt' },
  { key: 'accessory', label: 'Аксессуар', icon: 'diamond' },
];

const statLabels: Record<AttributeStat, string> = {
  attack: 'Атака',
  defense: 'Защита',
  agility: 'Ловкость',
  maxHp: 'Макс. здоровье',
  maxMana: 'Макс. мана',
};

const trainingActions: Array<{
  key: AttributeStat;
  title: string;
  description: string;
  cost: number;
  icon: keyof typeof Ionicons.glyphMap;
}> = [
  {
    key: 'attack',
    title: 'Спарринг клинков',
    description: 'Укрепляет боевую технику и прибавляет к атаке.',
    cost: 60,
    icon: 'flash',
  },
  {
    key: 'defense',
    title: 'Щиты и стойки',
    description: 'Повышает выносливость и защиту от ударов.',
    cost: 60,
    icon: 'shield',
  },
  {
    key: 'agility',
    title: 'Тропа ловкости',
    description: 'Развивает скорость, реакцию и гибкость.',
    cost: 60,
    icon: 'walk',
  },
  {
    key: 'maxHp',
    title: 'Закалка тела',
    description: 'Увеличивает предел жизненной силы героя.',
    cost: 80,
    icon: 'heart-circle',
  },
  {
    key: 'maxMana',
    title: 'Медитация потока',
    description: 'Расширяет резерв маны для долгих ритуалов.',
    cost: 80,
    icon: 'water',
  },
];

const formatBonuses = (item?: InventoryItem) => {
  if (!item?.bonuses) {
    return [];
  }
  const result: string[] = [];
  (Object.keys(statLabels) as AttributeStat[]).forEach((stat) => {
    const value = item.bonuses?.[stat];
    if (typeof value === 'number' && value !== 0) {
      result.push(`${statLabels[stat]} +${value}`);
    }
  });
  return result;
};

export default function CampScreen() {
  const {
    state,
    longRest,
    increaseAttribute,
    useConsumable,
    equipItem,
    unequipItem,
    setStyleAccent,
    trainDiscipline,
    claimDailyGoal,
    resetDailyGoals,
  } = useHero();

  const [campMessage, setCampMessage] = useState<string | null>(null);
  const messageTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const accent = useMemo(
    () => accentPalette[state.styleAccent],
    [state.styleAccent],
  );
  const accentArt = useMemo(
    () => accentIllustrations[state.styleAccent],
    [state.styleAccent],
  );

  const clearMessageTimeout = useCallback(() => {
    if (messageTimeoutRef.current) {
      clearTimeout(messageTimeoutRef.current);
      messageTimeoutRef.current = null;
    }
  }, []);

  const showMessage = useCallback(
    (text: string, duration = 2200) => {
      clearMessageTimeout();
      setCampMessage(text);
      messageTimeoutRef.current = setTimeout(() => {
        setCampMessage(null);
        messageTimeoutRef.current = null;
      }, duration);
    },
    [clearMessageTimeout],
  );

  const handleRest = useCallback(() => {
    longRest();
    showMessage('Вы отдыхаете у огня, полностью восстанавливая силы.');
  }, [longRest, showMessage]);

  const handleUpgrade = useCallback(
    (key: AttributeOption['key']) => {
      const { message } = increaseAttribute(key);
      showMessage(message);
    },
    [increaseAttribute, showMessage],
  );

  const handleConsumable = useCallback(
    (itemId: string) => {
      const { message } = useConsumable(itemId);
      showMessage(message);
    },
    [showMessage, useConsumable],
  );

  const handleEquip = useCallback(
    (itemId: string) => {
      const { message } = equipItem(itemId);
      showMessage(message);
    },
    [equipItem, showMessage],
  );

  const handleUnequip = useCallback(
    (slot: EquipmentSlot) => {
      const { message } = unequipItem(slot);
      showMessage(message);
    },
    [showMessage, unequipItem],
  );

  const handleTraining = useCallback(
    (stat: AttributeStat) => {
      const { message } = trainDiscipline(stat);
      showMessage(message);
    },
    [showMessage, trainDiscipline],
  );

  const handleGoalClaim = useCallback(
    (goalId: string) => {
      const { message } = claimDailyGoal(goalId);
      showMessage(message);
    },
    [claimDailyGoal, showMessage],
  );

  const handleAccentSelect = useCallback(
    (accent: HeroStyleAccent) => {
      setStyleAccent(accent);
      showMessage('Образ обновлён. Гармония цвета усиливает ауру героя.');
    },
    [setStyleAccent, showMessage],
  );

  const renderInventoryAction = useCallback(
    (item: InventoryItem) => {
      const isEquippable = ['weapon', 'armor', 'outfit', 'accessory'].includes(
        item.type,
      );
      if (isEquippable) {
        return (
          <Pressable
            onPress={() => handleEquip(item.id)}
            className="mt-3 flex-row items-center justify-center rounded-2xl bg-indigo-500/20 px-4 py-2"
          >
            <Ionicons name="shirt" size={16} color="#818cf8" />
            <Text className="ml-2 text-indigo-200 font-semibold">
              Экипировать
            </Text>
          </Pressable>
        );
      }
      if (item.type === 'consumable') {
        return (
          <Pressable
            onPress={() => handleConsumable(item.id)}
            className="mt-3 flex-row items-center justify-center rounded-2xl bg-emerald-500/20 px-4 py-2"
          >
            <Ionicons name="flask" size={16} color="#34d399" />
            <Text className="ml-2 text-emerald-200 font-semibold">
              Использовать
            </Text>
          </Pressable>
        );
      }
      return (
        <View className="mt-3 rounded-xl bg-slate-800/60 px-3 py-2">
          <Text className="text-slate-400 text-xs">
            {item.type === 'artifact' &&
              'Артефакт усиливает героя, пока находится при нём.'}
            {item.type === 'quest' &&
              'Особый предмет, связанный с сюжетным заданием.'}
          </Text>
        </View>
      );
    },
    [handleConsumable, handleEquip],
  );

  React.useEffect(() => {
    return () => {
      if (messageTimeoutRef.current) {
        clearTimeout(messageTimeoutRef.current);
      }
    };
  }, []);

  return (
    <View className="flex-1 bg-slate-950">
      <ScrollView className="flex-1">
        <View className="px-5 pt-12 pb-6">
          <Text className="text-slate-200 text-2xl font-semibold">
            Лагерь и подготовка
          </Text>
          <Text className="text-slate-400 mt-1">
            Здесь вы укрепляете дух, настраиваете облик и готовите снаряжение
            перед следующими свершениями.
          </Text>
        </View>

        {campMessage ? (
          <View
            className={`mx-5 mb-4 rounded-3xl border ${accent.border} ${accent.surface} p-4 ${accent.glow}`}
          >
            <View className="flex-row items-start">
              <Ionicons name="color-wand" size={20} color={accent.icon} />
              <Text className={`ml-3 flex-1 leading-6 ${accent.text}`}>
                {campMessage}
              </Text>
            </View>
          </View>
        ) : null}

        <View className="px-5 mt-4">
          <View
            className={`rounded-3xl border ${accent.border} ${accent.surface} p-5 ${accent.glow}`}
          >
            <View className="flex-row items-center">
              <View className="flex-1 pr-4">
                <Text className="text-slate-200 text-base font-semibold">
                  Лагерь настроен
                </Text>
                <Text className={`${accent.text} mt-1 text-sm`}>
                  Пламя отражает выбранный акцент. Настройте снаряжение и
                  готовьтесь к новым подвигам.
                </Text>
                <View className="mt-3 flex-row">
                  <View className="mr-5">
                    <Text className="text-slate-500 text-xs uppercase">
                      Мудрость
                    </Text>
                    <Text className="text-slate-200 mt-1 text-sm font-semibold">
                      {state.level}
                    </Text>
                  </View>
                  <View className="mr-5">
                    <Text className="text-slate-500 text-xs uppercase">
                      Реликвии
                    </Text>
                    <Text className="text-slate-200 mt-1 text-sm font-semibold">
                      {state.relics.length}
                    </Text>
                  </View>
                  <View>
                    <Text className="text-slate-500 text-xs uppercase">
                      Очки навыка
                    </Text>
                    <Text className="text-slate-200 mt-1 text-sm font-semibold">
                      {state.skillPoints}
                    </Text>
                  </View>
                </View>
              </View>
              <View className="h-28 w-28 overflow-hidden rounded-3xl bg-slate-900/60">
                <Image
                  source={{ uri: accentArt }}
                  className="h-full w-full"
                  resizeMode="cover"
                />
              </View>
            </View>
          </View>
        </View>

        <View className="px-5 mt-6">
          <View className="rounded-3xl border border-slate-700/60 bg-slate-900/80 p-5">
            <View className="flex-row items-center justify-between">
              <Text className="text-slate-200 text-lg font-semibold">
                Состояние героя
              </Text>
              <Pressable
                onPress={handleRest}
                className="flex-row items-center rounded-2xl bg-sky-500/20 px-3 py-2"
              >
                <Ionicons name="bonfire" size={16} color="#38bdf8" />
                <Text className="ml-2 text-sky-300 font-semibold">
                  Отдохнуть
                </Text>
              </Pressable>
            </View>
            <View className="mt-4">
              <View>
                <View className="flex-row items-center justify-between">
                  <Text className="text-slate-400">Здоровье</Text>
                  <Text className="text-emerald-400 font-semibold">
                    {state.hp}/{state.maxHp}
                  </Text>
                </View>
                <SegmentedProgress
                  value={state.hp}
                  max={state.maxHp}
                  filledClassName="bg-emerald-500"
                />
              </View>
              <View className="mt-4">
                <View className="flex-row items-center justify-between">
                  <Text className="text-slate-400">Мана</Text>
                  <Text className="text-sky-400 font-semibold">
                    {state.mana}/{state.maxMana}
                  </Text>
                </View>
                <SegmentedProgress
                  value={state.mana}
                  max={state.maxMana}
                  filledClassName="bg-sky-500"
                />
              </View>
            </View>
            <View className="mt-5 flex-row justify-between">
              <View>
                <Text className="text-slate-500 text-xs uppercase">Атака</Text>
                <Text className="text-slate-200 text-lg font-semibold">
                  {state.attack}
                </Text>
              </View>
              <View>
                <Text className="text-slate-500 text-xs uppercase">Защита</Text>
                <Text className="text-slate-200 text-lg font-semibold">
                  {state.defense}
                </Text>
              </View>
              <View>
                <Text className="text-slate-500 text-xs uppercase">
                  Ловкость
                </Text>
                <Text className="text-slate-200 text-lg font-semibold">
                  {state.agility}
                </Text>
              </View>
              <View>
                <Text className="text-slate-500 text-xs uppercase">
                  Очки навыка
                </Text>
                <Text className="text-indigo-300 text-lg font-semibold">
                  {state.skillPoints}
                </Text>
              </View>
            </View>
          </View>
        </View>

        <View className="px-5 mt-6">
          <View className="flex-row items-center justify-between">
            <Text className="text-slate-200 text-xl font-semibold">
              Дневные цели
            </Text>
            <Pressable
              onPress={() => {
                resetDailyGoals();
                showMessage('Список дневных задач обновлён.');
              }}
              className="rounded-2xl bg-slate-800/60 px-3 py-1"
            >
              <Text className="text-slate-300 text-xs font-semibold">
                Обновить
              </Text>
            </Pressable>
          </View>
          {state.dailyGoals.length === 0 ? (
            <View className="mt-4 rounded-3xl border border-slate-700/60 bg-slate-900/80 p-4">
              <Text className="text-slate-500">
                Ежедневные задачи ещё не доступны.
              </Text>
            </View>
          ) : (
            state.dailyGoals.map((goal) => {
              const isReady = goal.completed && !goal.claimed;
              return (
                <View
                  key={goal.id}
                  className="mt-4 rounded-3xl border border-slate-700/60 bg-slate-900/80 p-4"
                >
                  <View className="flex-row items-start justify-between">
                    <View className="flex-1 pr-3">
                      <Text className="text-slate-200 text-base font-semibold">
                        {goal.title}
                      </Text>
                      <Text className="text-slate-500 mt-1 text-sm">
                        {goal.description}
                      </Text>
                    </View>
                    {isReady ? (
                      <Pressable
                        onPress={() => handleGoalClaim(goal.id)}
                        className="rounded-2xl bg-emerald-500/20 px-3 py-2"
                      >
                        <Text className="text-emerald-200 text-sm font-semibold">
                          Забрать
                        </Text>
                      </Pressable>
                    ) : (
                      <View className="rounded-2xl bg-slate-800/60 px-3 py-2">
                        <Text className="text-slate-500 text-sm font-semibold">
                          {goal.claimed
                            ? 'Получено'
                            : `${goal.progress}/${goal.goal}`}
                        </Text>
                      </View>
                    )}
                  </View>
                  <View className="mt-3">
                    <SegmentedProgress
                      value={goal.progress}
                      max={goal.goal}
                      filledClassName="bg-emerald-500"
                    />
                    <Text className="text-slate-400 mt-2 text-xs">
                      Награда: {goal.rewardXp} опыта · {goal.rewardCoins} монет
                    </Text>
                  </View>
                </View>
              );
            })
          )}
        </View>

        <View className="px-5 mt-6">
          <Text className="text-slate-200 text-xl font-semibold">
            Тренировочные упражнения
          </Text>
          <Text className="text-slate-500 mt-1">
            Потратьте монеты лагеря, чтобы отточить мастерство.
          </Text>
          {trainingActions.map((action, index) => {
            const isDisabled = state.coins < action.cost;
            return (
              <Pressable
                key={action.key}
                onPress={() => handleTraining(action.key)}
                disabled={isDisabled}
                className={`${index === 0 ? 'mt-4' : 'mt-3'} rounded-3xl border border-slate-700/60 bg-slate-900/80 p-4 ${
                  isDisabled ? 'opacity-60' : 'opacity-100'
                }`}
              >
                <View className="flex-row items-start">
                  <View className="h-10 w-10 items-center justify-center rounded-2xl bg-slate-800/70">
                    <Ionicons
                      name={action.icon}
                      size={20}
                      color={accent.icon}
                    />
                  </View>
                  <View className="ml-4 flex-1">
                    <Text className="text-slate-200 text-base font-semibold">
                      {action.title}
                    </Text>
                    <Text className="text-slate-500 mt-1 leading-6">
                      {action.description}
                    </Text>
                    <Text className="text-slate-600 mt-2 text-xs uppercase">
                      Стоимость: {action.cost} монет
                    </Text>
                  </View>
                </View>
              </Pressable>
            );
          })}
        </View>

        <View className="px-5 mt-8">
          <Text className="text-slate-200 text-xl font-semibold">
            Образ и акценты
          </Text>

          <Text className="text-slate-500 mt-1">
            Выберите, какие цвета и энергия будут сопровождать ваши подвиги.
          </Text>
          <View className="mt-4">
            {accentOptions.map((option, index) => {
              const isSelected = state.styleAccent === option.key;
              const optionAccent = accentPalette[option.key];
              return (
                <Pressable
                  key={option.key}
                  onPress={() => handleAccentSelect(option.key)}
                  className={`${index === 0 ? 'mt-2' : 'mt-4'} rounded-3xl border ${
                    isSelected ? optionAccent.border : 'border-slate-700/60'
                  } ${isSelected ? optionAccent.surface : 'bg-slate-900/80'} p-4 ${
                    isSelected ? optionAccent.glow : ''
                  }`}
                >
                  <View className="flex-row items-start">
                    <View className="h-10 w-10 items-center justify-center rounded-2xl bg-slate-800/70">
                      <Ionicons
                        name={isSelected ? 'color-palette' : 'ellipse-outline'}
                        size={20}
                        color={optionAccent.icon}
                      />
                    </View>
                    <View className="ml-4 flex-1">
                      <Text className="text-slate-200 text-base font-semibold">
                        {option.title}
                      </Text>
                      <Text className="text-slate-500 mt-1 leading-6">
                        {option.description}
                      </Text>
                    </View>
                    {isSelected ? (
                      <Ionicons
                        name="checkmark-circle"
                        size={22}
                        color={optionAccent.icon}
                      />
                    ) : null}
                  </View>
                </Pressable>
              );
            })}
          </View>
        </View>

        <View className="px-5 mt-8">
          <Text className="text-slate-200 text-xl font-semibold">
            Экипировка
          </Text>
          <Text className="text-slate-500 mt-1">
            Следите за состоянием оружия, доспехов и украшений.
          </Text>
          <View className="mt-4">
            {equipmentSlots.map((slot, index) => {
              const item = state.equipment[slot.key];
              const bonuses = formatBonuses(item);
              return (
                <View
                  key={slot.key}
                  className={`${index === 0 ? 'mt-2' : 'mt-4'} rounded-3xl border border-slate-700/60 bg-slate-900/80 p-4`}
                >
                  <View className="flex-row items-start justify-between">
                    <View className="flex-row items-start">
                      <View className="h-10 w-10 items-center justify-center rounded-2xl bg-slate-800/70">
                        <Ionicons name={slot.icon} size={20} color="#38bdf8" />
                      </View>
                      <View className="ml-4">
                        <Text className="text-slate-400 text-xs uppercase">
                          {slot.label}
                        </Text>
                        <Text className="text-slate-200 mt-1 text-base font-semibold">
                          {item?.name ?? 'Не экипировано'}
                        </Text>
                      </View>
                    </View>
                    {item ? (
                      <Pressable
                        onPress={() => handleUnequip(slot.key)}
                        className="rounded-2xl bg-slate-800/70 px-3 py-1"
                      >
                        <Text className="text-slate-300 text-sm font-semibold">
                          Снять
                        </Text>
                      </Pressable>
                    ) : null}
                  </View>
                  {item ? (
                    <View className="mt-3">
                      <Text className="text-slate-500 text-sm">
                        {item.description}
                      </Text>
                      {bonuses.length > 0 ? (
                        <View className="mt-2">
                          {bonuses.map((bonus) => (
                            <Text
                              key={bonus}
                              className="text-emerald-300 text-sm"
                            >
                              {bonus}
                            </Text>
                          ))}
                        </View>
                      ) : null}
                    </View>
                  ) : (
                    <Text className="text-slate-500 mt-3 text-sm">
                      Подберите подходящий предмет в магазине или в
                      приключениях, чтобы усилить этот слот.
                    </Text>
                  )}
                </View>
              );
            })}
          </View>
        </View>

        <View className="px-5 mt-8">
          <Text className="text-slate-200 text-xl font-semibold">
            Обучение и развитие
          </Text>
          <Text className="text-slate-500 mt-1">
            Распределите полученные очки навыков, чтобы настроить свой стиль
            боя.
          </Text>
          <View className="mt-4">
            {attributeOptions.map((option, index) => (
              <Pressable
                key={option.key}
                onPress={() => handleUpgrade(option.key)}
                disabled={state.skillPoints <= 0}
                className={`${index === 0 ? 'mt-2' : 'mt-4'} rounded-3xl border border-slate-700/60 bg-slate-900/80 p-4 ${
                  state.skillPoints <= 0 ? 'opacity-60' : 'opacity-100'
                }`}
              >
                <View className="flex-row items-start">
                  <View className="h-11 w-11 items-center justify-center rounded-2xl bg-slate-800/70">
                    <Ionicons name={option.icon} size={20} color="#38bdf8" />
                  </View>
                  <View className="ml-4 flex-1">
                    <Text className="text-slate-200 text-base font-semibold">
                      {option.title}
                    </Text>
                    <Text className="text-slate-500 mt-1 leading-6">
                      {option.description}
                    </Text>
                  </View>
                  <Ionicons
                    name="add"
                    size={22}
                    color={state.skillPoints > 0 ? '#38bdf8' : '#64748b'}
                  />
                </View>
                <Text className={`mt-3 font-semibold ${option.highlight}`}>
                  {option.key === 'attack' &&
                    `Текущий показатель: ${state.attack}`}
                  {option.key === 'defense' &&
                    `Текущий показатель: ${state.defense}`}
                  {option.key === 'agility' &&
                    `Текущий показатель: ${state.agility}`}
                  {option.key === 'maxHp' &&
                    `Максимум здоровья: ${state.maxHp}`}
                  {option.key === 'maxMana' &&
                    `Максимум маны: ${state.maxMana}`}
                </Text>
              </Pressable>
            ))}
          </View>
        </View>

        <View className="px-5 mt-8">
          <Text className="text-slate-200 text-xl font-semibold">
            Реликвии и память
          </Text>
          <View className="mt-3 rounded-3xl border border-slate-700/60 bg-slate-900/80 p-4">
            {state.relics.length === 0 ? (
              <Text className="text-slate-500">
                Пока реликвии молчат. Отправляйтесь на поиски, чтобы раскрыть
                древние силы.
              </Text>
            ) : (
              state.relics.map((relic, index) => (
                <View key={relic} className={index === 0 ? 'mt-0' : 'mt-3'}>
                  <Text className="text-emerald-300 font-semibold">
                    {relic}
                  </Text>
                  <Text className="text-slate-500 mt-1">
                    Энергия реликвии переливается в крови, усиливая связь с
                    эфиром.
                  </Text>
                </View>
              ))
            )}
          </View>
        </View>

        <View className="px-5 mt-8">
          <Text className="text-slate-200 text-xl font-semibold">
            Инвентарь
          </Text>
          {state.inventory.length === 0 ? (
            <View className="mt-4 rounded-3xl border border-slate-700/60 bg-slate-900/80 p-5">
              <Text className="text-slate-500">
                У вас нет предметов. Исследуйте мир или выполняйте задания,
                чтобы пополнить сумку.
              </Text>
            </View>
          ) : (
            state.inventory.map((item, index) => (
              <View
                key={`${item.id}-${index}`}
                className={`${index === 0 ? 'mt-4' : 'mt-5'} rounded-3xl border border-slate-700/60 bg-slate-900/80 p-5`}
              >
                <View className="flex-row items-start justify-between">
                  <View className="flex-1 pr-3">
                    <Text className="text-slate-200 text-base font-semibold">
                      {item.name}
                    </Text>
                    <Text
                      className={`${rarityColors[item.rarity]} mt-1 font-semibold uppercase text-xs`}
                    >
                      {item.rarity}
                    </Text>
                    <Text className="text-slate-500 mt-2 leading-6">
                      {item.description}
                    </Text>
                    {item.bonuses ? (
                      <Text className="text-emerald-300 mt-2 text-sm">
                        {formatBonuses(item).join(', ')}
                      </Text>
                    ) : null}
                    {item.effect ? (
                      <Text className="text-slate-400 mt-2 text-sm">
                        Эффект:{' '}
                        {item.effect.type === 'heal' &&
                          `Восстановление ${item.effect.value} здоровья.`}
                        {item.effect.type === 'mana' &&
                          `Восстановление ${item.effect.value} маны.`}
                        {item.effect.type === 'buff' &&
                          item.effect.stat &&
                          `Усиление ${item.effect.stat} на ${item.effect.value}.`}
                        {item.effect.type === 'quest' &&
                          'Ключевой предмет сюжета.'}
                      </Text>
                    ) : null}
                  </View>
                  <View className="items-end">
                    <View className="rounded-2xl bg-slate-800/70 px-3 py-1">
                      <Text className="text-slate-300 text-sm">
                        x{item.quantity}
                      </Text>
                    </View>
                    <Text className="mt-2 text-amber-300 font-semibold">
                      {item.value} мон.
                    </Text>
                  </View>
                </View>
                {renderInventoryAction(item)}
              </View>
            ))
          )}
        </View>

        <View className="h-16" />
      </ScrollView>
    </View>
  );
}

```

## File: /src/app/(tabs)/community.tsx
```
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { Pressable, ScrollView, Text, TextInput, View } from 'react-native';
import Ionicons from '@expo/vector-icons/Ionicons';
import { useHero } from '../../context/HeroContext';
import { accentPalette } from '../../utils/accent';
import { SegmentedProgress } from '../../components/SegmentedProgress';
import {
  useCommunity,
  type ArenaOpponent,
  type MarketListing,
  type PvPMatchRecord,
} from '../../context/CommunityContext';

const formatRelativeTime = (iso?: string | null) => {
  if (!iso) {
    return 'только что';
  }
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) {
    return 'только что';
  }
  const diffMs = Date.now() - date.getTime();
  if (diffMs < 0) {
    return 'только что';
  }
  const minutes = Math.floor(diffMs / 60000);
  if (minutes < 1) {
    return 'только что';
  }
  if (minutes < 60) {
    return `${minutes} мин назад`;
  }
  const hours = Math.floor(minutes / 60);
  if (hours < 24) {
    return `${hours} ч назад`;
  }
  const days = Math.floor(hours / 24);
  return `${days} дн назад`;
};

const formatTimeLeft = (iso?: string) => {
  if (!iso) {
    return 'без срока';
  }
  const target = new Date(iso);
  if (Number.isNaN(target.getTime())) {
    return 'неизвестно';
  }
  const diffMs = target.getTime() - Date.now();
  if (diffMs <= 0) {
    return 'истекло';
  }
  const minutes = Math.floor(diffMs / 60000);
  if (minutes < 60) {
    return `${minutes} мин`;
  }
  const hours = Math.floor(minutes / 60);
  if (hours < 24) {
    const rest = minutes - hours * 60;
    return rest >= 15 ? `${hours} ч` : `${hours} ч ${rest} мин`;
  }
  const days = Math.floor(hours / 24);
  return `${days} дн`;
};

const resultLabels: Record<PvPMatchRecord['result'], string> = {
  win: 'Победа',
  loss: 'Поражение',
  draw: 'Ничья',
};

const resultStyles: Record<
  PvPMatchRecord['result'],
  { container: string; text: string }
> = {
  win: {
    container: 'border-emerald-500/40 bg-emerald-500/10',
    text: 'text-emerald-200',
  },
  loss: {
    container: 'border-rose-500/40 bg-rose-500/10',
    text: 'text-rose-200',
  },
  draw: {
    container: 'border-slate-500/40 bg-slate-500/10',
    text: 'text-slate-200',
  },
};

export default function CommunityScreen() {
  const {
    state: heroState,
    spendCoins,
    earnCoins,
    addInventoryItem,
    gainXp,
    trackHeroStat,
    advanceQuest,
  } = useHero();
  const {
    state: communityState,
    roster,
    selfProfile,
    sendMessage,
    purchaseListing,
    refreshMarketplace,
    recordBattle,
    refreshArenaOpponents,
  } = useCommunity();

  const [messageDraft, setMessageDraft] = useState('');
  const [tradeFeedback, setTradeFeedback] = useState<string | null>(null);
  const [battleFeedback, setBattleFeedback] = useState<string | null>(null);

  const accent = useMemo(
    () => accentPalette[heroState.styleAccent],
    [heroState.styleAccent],
  );

  const heroLeaderboardEntry = useMemo(() => {
    const heroId = 'hero-main-entry';
    return (
      communityState.leaderboard.find((entry) => entry.id === heroId) ??
      communityState.leaderboard.find((entry) => entry.name === heroState.name)
    );
  }, [communityState.leaderboard, heroState.name]);

  const heroRating = heroLeaderboardEntry?.rating ?? 1320;
  const heroWins = heroLeaderboardEntry?.wins ?? 0;
  const heroLosses = heroLeaderboardEntry?.losses ?? 0;
  const heroDraws = heroLeaderboardEntry?.draws ?? 0;
  const heroStreak = heroLeaderboardEntry?.streak ?? 0;

  const ratingProgressValue = Math.max(0, Math.min(1600, heroRating) - 1100);

  const chatMessages = useMemo(
    () => communityState.chatMessages.slice(-18),
    [communityState.chatMessages],
  );

  const lastChatTimestamp =
    chatMessages.length > 0
      ? chatMessages[chatMessages.length - 1]?.timestamp
      : undefined;

  const marketplaceItems = communityState.marketplace;
  const opponents = communityState.arenaOpponents;
  const communityPlayers = roster.length;

  const recentMatches = useMemo(
    () => communityState.pvpHistory.slice(-6).reverse(),
    [communityState.pvpHistory],
  );

  const handleSendMessage = useCallback(() => {
    const trimmed = messageDraft.trim();
    if (!trimmed) {
      return;
    }
    sendMessage(heroState.name, trimmed, { isSelf: true, tone: 'player' });
    setMessageDraft('');
  }, [messageDraft, sendMessage, heroState.name]);

  const handlePurchase = useCallback(
    (listing: MarketListing) => {
      if (!spendCoins(listing.price)) {
        setTradeFeedback('Недостаточно монет для сделки.');
        return;
      }
      const {
        success,
        message,
        listing: confirmed,
      } = purchaseListing(listing.id);
      if (!success || !confirmed) {
        earnCoins(listing.price);
        setTradeFeedback(message);
        return;
      }
      addInventoryItem({
        ...confirmed.item,
        quantity: confirmed.item.quantity ?? 1,
      });
      trackHeroStat({
        purchasesMade: 1,
      });

      setTradeFeedback(`Добавлено в инвентарь: ${confirmed.item.name}.`);
    },
    [addInventoryItem, earnCoins, purchaseListing, spendCoins, trackHeroStat],
  );

  const handleChallenge = useCallback(
    (opponent: ArenaOpponent) => {
      const heroPower = Math.round(
        heroState.level * 55 +
          (heroState.attack + heroState.defense + heroState.agility) * 14 +
          heroState.maxHp * 0.45 +
          heroState.maxMana * 0.35,
      );
      const result = recordBattle({
        opponentId: opponent.id,
        heroName: heroState.name,
        heroLevel: heroState.level,
        heroPower,
      });
      gainXp(result.rewardXp);
      earnCoins(result.rewardCoins);
      if (result.result === 'win') {
        trackHeroStat({ battlesWon: 1 });
      }
      advanceQuest('battle', 1);
      setBattleFeedback(
        `${result.summary} Награда: ${result.rewardXp} опыта и ${result.rewardCoins} монет.`,
      );
    },
    [advanceQuest, earnCoins, gainXp, heroState, recordBattle, trackHeroStat],
  );

  const heroKdaLabel = useMemo(() => {
    const total = heroWins + heroLosses + heroDraws;
    if (total === 0) {
      return 'Нет боёв';
    }
    return `${heroWins}-${heroLosses}-${heroDraws}`;
  }, [heroWins, heroLosses, heroDraws]);

  useEffect(() => {
    if (!tradeFeedback) {
      return;
    }
    const timer = setTimeout(() => setTradeFeedback(null), 2600);
    return () => clearTimeout(timer);
  }, [tradeFeedback]);

  useEffect(() => {
    if (!battleFeedback) {
      return;
    }
    const timer = setTimeout(() => setBattleFeedback(null), 3200);
    return () => clearTimeout(timer);
  }, [battleFeedback]);

  return (
    <View className="flex-1 bg-slate-950">
      <ScrollView className="flex-1">
        <View className="px-5 pt-12 pb-6">
          <Text className="text-slate-200 text-2xl font-semibold">
            Лига Эраэлиона
          </Text>
          <Text className="text-slate-400 mt-1">
            Общайтесь с героями, заключайте сделки и сражайтесь за место в
            рейтинге.
          </Text>
        </View>

        {tradeFeedback ? (
          <View
            className={`mx-5 mb-4 rounded-3xl border ${accent.border} ${accent.surface} p-4 ${accent.glow}`}
          >
            <View className="flex-row items-center">
              <Ionicons name="sparkles" size={18} color={accent.icon} />
              <Text className={`${accent.text} ml-2`}>{tradeFeedback}</Text>
            </View>
          </View>
        ) : null}

        {battleFeedback ? (
          <View className="mx-5 mb-4 rounded-3xl border border-violet-500/30 bg-violet-500/10 p-4">
            <View className="flex-row items-center">
              <Ionicons name="trophy" size={18} color="#c4b5fd" />
              <Text className="ml-2 text-violet-100">{battleFeedback}</Text>
            </View>
          </View>
        ) : null}

        <View className="px-5">
          <View
            className={`rounded-3xl border ${accent.border} ${accent.surface} p-5 ${accent.glow}`}
          >
            <View className="flex-row items-center justify-between">
              <View className="flex-1 pr-4">
                <Text className="text-slate-400 text-xs uppercase">Арена</Text>
                <Text className="text-slate-200 mt-1 text-2xl font-semibold">
                  Рейтинг {heroRating}
                </Text>
                <Text className="text-slate-400 mt-1 text-sm">
                  Статистика: {heroKdaLabel}
                </Text>
                <Text className="text-slate-500 mt-1 text-xs">
                  Серия{' '}
                  {heroStreak > 0
                    ? `побед +${heroStreak}`
                    : heroStreak < 0
                      ? `поражений ${heroStreak}`
                      : 'без серии'}
                </Text>
                <Text className="text-slate-500 mt-1 text-xs">
                  Игроков в сети: {communityPlayers}
                </Text>
              </View>
              <View className="w-20">
                <SegmentedProgress
                  value={ratingProgressValue}
                  max={500}
                  filledClassName="bg-sky-500"
                  emptyClassName="bg-slate-800"
                />
                <Text className="text-slate-500 mt-2 text-xs">
                  До легенды: {Math.max(0, 1600 - heroRating)} оч.
                </Text>
              </View>
            </View>
          </View>
        </View>

        <View className="px-5 mt-8">
          <Text className="text-slate-200 text-xl font-semibold">
            Городской чат
          </Text>
          <View className="mt-4 rounded-3xl border border-slate-700/60 bg-slate-900/70 p-5">
            <View className="flex-row items-center justify-between">
              <Text className="text-slate-400 text-xs uppercase">
                Последние обсуждения
              </Text>
              <Text className="text-slate-500 text-xs">
                Обновлено {formatRelativeTime(lastChatTimestamp)}
              </Text>
            </View>
            <View className="mt-4">
              {chatMessages.map((message) => (
                <View
                  key={message.id}
                  className={`mb-3 rounded-3xl border px-4 py-3 ${message.isSelf ? 'self-end border-sky-500/40 bg-sky-500/10' : 'border-slate-700/60 bg-slate-900/60'}`}
                >
                  <View className="flex-row items-center">
                    <Ionicons
                      name={message.isSelf ? 'person' : 'chatbubble-ellipses'}
                      size={14}
                      color={message.isSelf ? '#38bdf8' : message.accent}
                    />
                    <Text className="ml-2 text-sm font-semibold text-slate-100">
                      {message.author}
                    </Text>
                    {message.badge ? (
                      <Text className="ml-2 rounded-full border border-amber-500/40 bg-amber-500/10 px-2 py-0.5 text-xs text-amber-200">
                        {message.badge}
                      </Text>
                    ) : null}
                    <Text className="ml-2 text-xs text-slate-500">
                      #{message.authorId.slice(-5)}
                    </Text>
                    <Text className="ml-auto text-xs text-slate-500">
                      {formatRelativeTime(message.timestamp)}
                    </Text>
                  </View>
                  {message.guild ? (
                    <Text className="mt-1 text-xs text-slate-500">
                      {message.guild}
                    </Text>
                  ) : null}
                  <Text className="mt-2 text-slate-200 text-sm leading-5">
                    {message.text}
                  </Text>
                </View>
              ))}
            </View>
            <View className="mt-4 rounded-2xl border border-slate-700/60 bg-slate-950/80 p-3">
              {selfProfile ? (
                <Text className="text-slate-500 text-xs">
                  Ваш ID: {selfProfile.id}
                </Text>
              ) : null}
              <TextInput
                value={messageDraft}
                onChangeText={setMessageDraft}
                placeholder={`От имени ${heroState.name} поделитесь новостями...`}
                placeholderTextColor="#475569"
                multiline
                className="text-slate-100 text-sm"
              />

              <Pressable
                onPress={handleSendMessage}
                className="mt-3 flex-row items-center justify-center rounded-2xl bg-sky-500/20 px-4 py-2"
              >
                <Ionicons name="send" size={16} color="#38bdf8" />
                <Text className="ml-2 text-sky-300 text-sm font-semibold">
                  Отправить
                </Text>
              </Pressable>
            </View>
          </View>
        </View>

        <View className="px-5 mt-8">
          <View className="flex-row items-center justify-between">
            <Text className="text-slate-200 text-xl font-semibold">
              Биржа игроков
            </Text>
            <Pressable
              onPress={refreshMarketplace}
              className="flex-row items-center rounded-2xl border border-slate-700/60 px-3 py-1.5"
            >
              <Ionicons name="refresh" size={14} color="#94a3b8" />
              <Text className="ml-2 text-xs text-slate-300">Обновить</Text>
            </Pressable>
          </View>
          <Text className="text-slate-500 mt-1 text-xs">
            Последнее обновление:{' '}
            {formatRelativeTime(communityState.lastMarketplaceRefresh)}
          </Text>
          <View className="mt-4">
            {marketplaceItems.map((listing) => (
              <View
                key={listing.id}
                className="mb-4 rounded-3xl border border-slate-700/60 bg-slate-900/70 p-5"
              >
                <View className="flex-row justify-between">
                  <View className="pr-4">
                    <Text className="text-slate-200 text-lg font-semibold">
                      {listing.item.name}
                    </Text>
                    <Text className="text-slate-400 mt-1 text-sm">
                      {listing.seller} · {listing.sellerGuild}
                    </Text>
                  </View>
                  <View className="items-end">
                    <Text className="text-amber-300 text-lg font-semibold">
                      {listing.price} мон.
                    </Text>
                    <Text className="text-slate-500 text-xs">
                      Спрос {listing.demand}%
                    </Text>
                  </View>
                </View>
                <Text className="text-slate-400 mt-3 text-sm leading-5">
                  {listing.item.description}
                </Text>
                {listing.featured ? (
                  <Text className="mt-2 rounded-full border border-sky-500/40 bg-sky-500/10 px-3 py-1 text-xs text-sky-200">
                    Рекомендовано гильдией
                  </Text>
                ) : null}
                <View className="mt-3 flex-row flex-wrap">
                  {listing.item.bonuses
                    ? Object.keys(listing.item.bonuses).map((key) => (
                        <View
                          key={`${listing.id}-${key}`}
                          className="mr-2 mt-2 rounded-full border border-slate-700/60 bg-slate-800/70 px-3 py-1"
                        >
                          <Text className="text-xs text-slate-300">
                            {key}: +
                            {
                              listing.item.bonuses?.[
                                key as keyof typeof listing.item.bonuses
                              ]
                            }
                          </Text>
                        </View>
                      ))
                    : null}
                </View>
                <View className="mt-3 flex-row items-center justify-between">
                  <Text className="text-slate-500 text-xs">
                    Остаток: {listing.stock}
                  </Text>
                  <Text className="text-slate-500 text-xs">
                    Срок: {formatTimeLeft(listing.expiresAt)}
                  </Text>
                </View>
                <Pressable
                  onPress={() => handlePurchase(listing)}
                  className="mt-4 flex-row items-center justify-center rounded-2xl bg-emerald-500/20 px-4 py-2"
                >
                  <Ionicons name="cart" size={16} color="#34d399" />
                  <Text className="ml-2 text-sm font-semibold text-emerald-200">
                    Заключить сделку
                  </Text>
                </Pressable>
              </View>
            ))}
          </View>
        </View>

        <View className="px-5 mt-8">
          <View className="flex-row items-center justify-between">
            <Text className="text-slate-200 text-xl font-semibold">Арена</Text>
            <Pressable
              onPress={refreshArenaOpponents}
              className="flex-row items-center rounded-2xl border border-slate-700/60 px-3 py-1.5"
            >
              <Ionicons name="sparkles" size={14} color="#a855f7" />
              <Text className="ml-2 text-xs text-slate-300">
                Новые соперники
              </Text>
            </Pressable>
          </View>
          <Text className="text-slate-500 mt-1 text-xs">
            Обновлено {formatRelativeTime(communityState.lastArenaRefresh)}
          </Text>
          <View className="mt-4">
            {opponents.map((opponent) => (
              <View
                key={opponent.id}
                className="mb-4 rounded-3xl border border-violet-500/20 bg-violet-500/5 p-5"
              >
                <View className="flex-row justify-between">
                  <View className="pr-4">
                    <Text className="text-slate-200 text-lg font-semibold">
                      {opponent.name}
                    </Text>
                    <Text className="text-slate-400 mt-1 text-sm">
                      {opponent.guild}
                    </Text>
                  </View>
                  <View className="items-end">
                    <Text className="text-violet-200 text-lg font-semibold">
                      {opponent.rating}
                    </Text>
                    <Text className="text-slate-500 text-xs">
                      Тренд:{' '}
                      {opponent.trend === 'up'
                        ? 'рост'
                        : opponent.trend === 'down'
                          ? 'падение'
                          : 'стабильность'}
                    </Text>
                  </View>
                </View>
                <Text className="text-slate-300 mt-3 text-sm">
                  Стиль: {opponent.style}
                </Text>
                <Text className="text-slate-500 mt-1 text-xs">
                  Темперамент: {opponent.temperament}. Награда предпочитается:{' '}
                  {opponent.preferredReward}.
                </Text>
                <View className="mt-3 flex-row items-center justify-between">
                  <Text className="text-slate-400 text-xs">
                    Мощь {opponent.power}
                  </Text>
                  <Pressable
                    onPress={() => handleChallenge(opponent)}
                    className="flex-row items-center rounded-2xl bg-violet-500/20 px-4 py-2"
                  >
                    <Ionicons name="sword" size={16} color="#c4b5fd" />
                    <Text className="ml-2 text-sm font-semibold text-violet-100">
                      Вызвать на дуэль
                    </Text>
                  </Pressable>
                </View>
              </View>
            ))}
          </View>
        </View>

        <View className="px-5 mt-8">
          <Text className="text-slate-200 text-xl font-semibold">
            Таблица лидеров
          </Text>
          <View className="mt-4 rounded-3xl border border-slate-700/60 bg-slate-900/70 p-5">
            {communityState.leaderboard
              .slice()
              .sort((a, b) => b.rating - a.rating)
              .map((entry, index) => (
                <View
                  key={entry.id}
                  className="mb-3 rounded-2xl border border-slate-700/60 bg-slate-950/70 px-4 py-3"
                >
                  <View className="flex-row items-center justify-between">
                    <View className="flex-row items-center">
                      <Text className="text-slate-500 text-xs">
                        #{index + 1}
                      </Text>
                      <Text className="ml-3 text-slate-200 text-sm font-semibold">
                        {entry.name}
                      </Text>
                    </View>
                    <Text className="text-sky-300 text-sm font-semibold">
                      {entry.rating}
                    </Text>
                  </View>
                  <Text className="text-slate-400 mt-1 text-xs">
                    {entry.title} · {entry.guild}
                  </Text>
                  <View className="mt-2 flex-row">
                    <Text className="text-xs text-emerald-300">
                      W {entry.wins}
                    </Text>
                    <Text className="ml-3 text-xs text-rose-300">
                      L {entry.losses}
                    </Text>
                    <Text className="ml-3 text-xs text-slate-300">
                      D {entry.draws}
                    </Text>
                  </View>
                  <Text className="text-slate-500 mt-1 text-xs">
                    Обновлено {formatRelativeTime(entry.lastUpdated)}
                  </Text>
                </View>
              ))}
          </View>
        </View>

        <View className="px-5 mt-8">
          <Text className="text-slate-200 text-xl font-semibold">
            История дуэлей
          </Text>
          {recentMatches.length === 0 ? (
            <View className="mt-4 rounded-3xl border border-slate-700/60 bg-slate-900/80 p-5">
              <Text className="text-slate-500">
                Пока нет записей. Испытайте себя на арене, чтобы заполнить
                хронику.
              </Text>
            </View>
          ) : (
            <View className="mt-4">
              {recentMatches.map((match) => (
                <View
                  key={match.id}
                  className={`mb-4 rounded-3xl border px-4 py-4 ${resultStyles[match.result].container}`}
                >
                  <View className="flex-row items-center justify-between">
                    <Text
                      className={`text-sm font-semibold ${resultStyles[match.result].text}`}
                    >
                      {resultLabels[match.result]}
                    </Text>

                    <Text className="text-xs text-slate-400">
                      {formatRelativeTime(match.timestamp)}
                    </Text>
                  </View>
                  <Text className="mt-2 text-slate-200 text-sm">
                    {match.summary}
                  </Text>
                  <View className="mt-3 flex-row items-center justify-between">
                    <Text className="text-xs text-slate-400">
                      Δ рейтинг{' '}
                      {match.ratingDelta >= 0
                        ? `+${match.ratingDelta}`
                        : match.ratingDelta}
                    </Text>
                    <Text className="text-xs text-slate-400">
                      Арена {match.opponentGuild}
                    </Text>
                    <Text className="text-xs text-slate-400">
                      Новый рейтинг {match.heroRatingAfter}
                    </Text>
                  </View>
                </View>
              ))}
            </View>
          )}
        </View>

        <View className="h-16" />
      </ScrollView>
    </View>
  );
}

```

## File: /src/app/(tabs)/quests.tsx
```
import React, { useCallback, useMemo, useState } from 'react';
import { Pressable, ScrollView, Text, View } from 'react-native';
import Ionicons from '@expo/vector-icons/Ionicons';
import { SegmentedProgress } from '../../components/SegmentedProgress';
import { useHero } from '../../context/HeroContext';
import type { Quest } from '../../context/HeroContext';
import { accentPalette } from '../../utils/accent';

const tagTranslations: Record<string, string> = {
  battle: 'Битва',
  forest: 'Лес',
  lore: 'Легенда',
  explore: 'Разведка',
  ritual: 'Ритуал',
  mystery: 'Тайна',
  craft: 'Ремесло',
  style: 'Образ',
  gear: 'Снаряжение',
  rescue: 'Спасение',
  diplomacy: 'Дипломатия',
  defense: 'Оборона',
};

const categoryMeta: Record<
  Quest['category'],
  {
    label: string;
    icon: keyof typeof Ionicons.glyphMap;
    badgeClass: string;
    textClass: string;
    iconColor: string;
  }
> = {
  hunt: {
    label: 'Охота',
    icon: 'flame-outline',
    badgeClass: 'border border-emerald-500/30 bg-emerald-500/10',
    textClass: 'text-emerald-300',
    iconColor: '#34d399',
  },
  expedition: {
    label: 'Экспедиция',
    icon: 'compass-outline',
    badgeClass: 'border border-sky-500/30 bg-sky-500/10',
    textClass: 'text-sky-300',
    iconColor: '#38bdf8',
  },
  ritual: {
    label: 'Ритуал',
    icon: 'moon-outline',
    badgeClass: 'border border-violet-500/30 bg-violet-500/10',
    textClass: 'text-violet-300',
    iconColor: '#a855f7',
  },
  crafting: {
    label: 'Ремесло',
    icon: 'hammer-outline',
    badgeClass: 'border border-amber-500/30 bg-amber-500/10',
    textClass: 'text-amber-300',
    iconColor: '#fbbf24',
  },
  investigation: {
    label: 'Расследование',
    icon: 'search-outline',
    badgeClass: 'border border-indigo-500/30 bg-indigo-500/10',
    textClass: 'text-indigo-300',
    iconColor: '#818cf8',
  },
  rescue: {
    label: 'Спасение',
    icon: 'heart-outline',
    badgeClass: 'border border-rose-500/30 bg-rose-500/10',
    textClass: 'text-rose-300',
    iconColor: '#fb7185',
  },
  diplomacy: {
    label: 'Дипломатия',
    icon: 'chatbubbles-outline',
    badgeClass: 'border border-cyan-500/30 bg-cyan-500/10',
    textClass: 'text-cyan-300',
    iconColor: '#22d3ee',
  },
  defense: {
    label: 'Оборона',
    icon: 'shield-checkmark-outline',
    badgeClass: 'border border-slate-500/30 bg-slate-500/10',
    textClass: 'text-slate-200',
    iconColor: '#a8b4cf',
  },
};

const rarityMeta: Record<
  Quest['rarity'],
  { label: string; badgeClass: string; textClass: string }
> = {
  routine: {
    label: 'Обычное',
    badgeClass: 'border border-slate-700/60 bg-slate-900/80',
    textClass: 'text-slate-300',
  },
  notable: {
    label: 'Примечательное',
    badgeClass: 'border border-sky-500/40 bg-sky-500/10',
    textClass: 'text-sky-200',
  },
  grand: {
    label: 'Грандиозное',
    badgeClass: 'border border-violet-500/40 bg-violet-500/10',
    textClass: 'text-violet-200',
  },
  legendary: {
    label: 'Легендарное',
    badgeClass: 'border border-amber-500/50 bg-amber-500/10',
    textClass: 'text-amber-200',
  },
};

const urgencyMeta: Record<
  Quest['urgency'],
  { label: string; badgeClass: string; textClass: string; iconColor: string }
> = {
  calm: {
    label: 'Размеренное',
    badgeClass: 'border border-emerald-500/40 bg-emerald-500/10',
    textClass: 'text-emerald-200',
    iconColor: '#34d399',
  },
  pressing: {
    label: 'Срочно',
    badgeClass: 'border border-amber-500/40 bg-amber-500/10',
    textClass: 'text-amber-200',
    iconColor: '#facc15',
  },
  critical: {
    label: 'Критично',
    badgeClass: 'border border-rose-500/50 bg-rose-500/10',
    textClass: 'text-rose-200',
    iconColor: '#fb7185',
  },
};

type CategorySummaryEntry = {
  category: Quest['category'];
  total: number;
  active: number;
  available: number;
};

const getQuestTone = (status: Quest['status']) => {
  if (status === 'completed') return 'border-emerald-500/30 bg-emerald-500/10';
  if (status === 'active') return 'border-sky-500/30 bg-sky-500/10';
  return 'border-slate-700/60 bg-slate-900/80';
};

const formatRelativeTime = (iso: string | null | undefined) => {
  if (!iso) {
    return 'никогда';
  }
  const date = new Date(iso);
  if (Number.isNaN(date.getTime())) {
    return 'неизвестно';
  }
  const diffMs = Date.now() - date.getTime();
  if (diffMs < 0) {
    return 'только что';
  }
  const minutes = Math.floor(diffMs / 60000);
  if (minutes < 1) {
    return 'только что';
  }
  if (minutes < 60) {
    return `${minutes} мин назад`;
  }
  const hours = Math.floor(minutes / 60);
  if (hours < 24) {
    return `${hours} ч назад`;
  }
  const days = Math.floor(hours / 24);
  return `${days} дн назад`;
};

const getExpiresLabel = (iso?: string) => {
  if (!iso) {
    return null;
  }
  const expiry = new Date(iso);
  if (Number.isNaN(expiry.getTime())) {
    return null;
  }
  const diffMs = expiry.getTime() - Date.now();
  if (diffMs <= 0) {
    return 'истекло';
  }
  const totalMinutes = Math.floor(diffMs / 60000);
  if (totalMinutes < 60) {
    return `${Math.max(1, totalMinutes)} мин`;
  }
  const hours = Math.floor(totalMinutes / 60);
  if (hours < 24) {
    const remainder = totalMinutes - hours * 60;
    return remainder >= 15 ? `${hours} ч` : `${hours} ч ${remainder} мин`;
  }
  const days = Math.floor(hours / 24);
  return `${days} дн`;
};

const isExpiringSoon = (iso?: string) => {
  if (!iso) {
    return false;
  }
  const expiry = new Date(iso);
  if (Number.isNaN(expiry.getTime())) {
    return false;
  }
  const diffMs = expiry.getTime() - Date.now();
  return diffMs > 0 && diffMs <= 12 * 60 * 60 * 1000;
};

export default function QuestsScreen() {
  const { state, acceptQuest, completeQuest, refreshQuestBoard } = useHero();
  const [toast, setToast] = useState<string | null>(null);
  const [isRefreshingBoard, setIsRefreshingBoard] = useState(false);

  const accent = useMemo(
    () => accentPalette[state.styleAccent],
    [state.styleAccent],
  );

  const activeQuests = useMemo(
    () => state.quests.filter((quest) => quest.status === 'active'),
    [state.quests],
  );
  const availableQuests = useMemo(
    () => state.quests.filter((quest) => quest.status === 'available'),
    [state.quests],
  );
  const completedQuests = useMemo(
    () => state.quests.filter((quest) => quest.status === 'completed'),
    [state.quests],
  );

  const lastRefreshLabel = useMemo(
    () => formatRelativeTime(state.questBoardLastRefresh),
    [state.questBoardLastRefresh],
  );

  const categorySummary = useMemo(() => {
    const summary = {} as Record<Quest['category'], CategorySummaryEntry>;
    (Object.keys(categoryMeta) as Array<Quest['category']>).forEach((key) => {
      summary[key] = {
        category: key,
        total: 0,
        active: 0,
        available: 0,
      };
    });
    state.quests.forEach((quest) => {
      const entry = summary[quest.category];
      entry.total += 1;
      if (quest.status === 'active') {
        entry.active += 1;
      } else if (quest.status === 'available') {
        entry.available += 1;
      }
    });
    return (Object.values(summary) as CategorySummaryEntry[])
      .filter((entry) => entry.total > 0)
      .sort((a, b) => {
        if (b.available !== a.available) {
          return b.available - a.available;
        }
        return b.total - a.total;
      });
  }, [state.quests]);

  const expiringSoonCount = useMemo(
    () =>
      availableQuests.filter((quest) => isExpiringSoon(quest.expiresAt)).length,
    [availableQuests],
  );

  const activeCompletion = useMemo(() => {
    if (activeQuests.length === 0) {
      return 0;
    }
    const totalRatio = activeQuests.reduce((sum, quest) => {
      const safeGoal = Math.max(1, quest.goal);
      return sum + quest.progress / safeGoal;
    }, 0);
    return Math.round((totalRatio / activeQuests.length) * 100);
  }, [activeQuests]);

  const handleAccept = useCallback(
    (questId: string) => {
      acceptQuest(questId);
      setToast('Задание добавлено в активные.');
      setTimeout(() => setToast(null), 1800);
    },
    [acceptQuest],
  );

  const handleComplete = useCallback(
    (questId: string) => {
      const { message } = completeQuest(questId);
      setToast(message);
      setTimeout(() => setToast(null), 2000);
    },
    [completeQuest],
  );

  const handleRefreshBoard = useCallback(() => {
    if (isRefreshingBoard) {
      return;
    }
    setIsRefreshingBoard(true);
    const { added, message } = refreshQuestBoard('full');
    const feedback = added > 0 ? `${message} (+${added})` : message;
    setToast(feedback);
    setTimeout(() => setToast(null), 2000);
    setTimeout(() => setIsRefreshingBoard(false), 650);
  }, [isRefreshingBoard, refreshQuestBoard, setToast]);

  const renderQuestActions = useCallback(
    (quest: Quest) => {
      if (quest.status === 'available') {
        return (
          <Pressable
            onPress={() => handleAccept(quest.id)}
            className="mt-4 flex-row items-center justify-center rounded-2xl bg-sky-500/20 px-4 py-2"
          >
            <Ionicons name="add-circle" size={18} color="#38bdf8" />
            <Text className="ml-2 text-sky-300 font-semibold">
              Принять задание
            </Text>
          </Pressable>
        );
      }
      if (quest.status === 'active') {
        return (
          <Pressable
            onPress={() => handleComplete(quest.id)}
            className="mt-4 flex-row items-center justify-center rounded-2xl bg-emerald-500/20 px-4 py-2"
          >
            <Ionicons name="checkmark-circle" size={18} color="#34d399" />
            <Text className="ml-2 text-emerald-300 font-semibold">
              Получить награду
            </Text>
          </Pressable>
        );
      }
      return (
        <View className="mt-4 flex-row items-center justify-center rounded-2xl bg-emerald-500/10 px-4 py-2">
          <Ionicons name="ribbon" size={18} color="#10b981" />
          <Text className="ml-2 text-emerald-200 font-semibold">Завершено</Text>
        </View>
      );
    },
    [handleAccept, handleComplete],
  );

  const renderQuestCard = useCallback(
    (quest: Quest, index: number) => {
      const safeGoal = Math.max(1, quest.goal);
      const boundedProgress = Math.max(0, Math.min(safeGoal, quest.progress));
      const categoryInfo = categoryMeta[quest.category];
      const rarityInfo = rarityMeta[quest.rarity];
      const urgencyInfo = urgencyMeta[quest.urgency];
      const expiresLabel = getExpiresLabel(quest.expiresAt);
      const soon = isExpiringSoon(quest.expiresAt);

      return (
        <View
          key={quest.id}
          className={`${index === 0 ? 'mt-4' : 'mt-5'} rounded-3xl border ${getQuestTone(quest.status)} p-5`}
        >
          <View className="flex-row items-start justify-between">
            <View className="flex-1 pr-4">
              <Text className="text-slate-200 text-lg font-semibold">
                {quest.title}
              </Text>
              <View className="mt-3 flex-row flex-wrap items-center">
                <View
                  className={`mr-2 mt-2 flex-row items-center rounded-full px-3 py-1 ${categoryInfo.badgeClass}`}
                >
                  <Ionicons
                    name={categoryInfo.icon}
                    size={14}
                    color={categoryInfo.iconColor}
                  />
                  <Text
                    className={`${categoryInfo.textClass} ml-2 text-xs font-semibold`}
                  >
                    {categoryInfo.label}
                  </Text>
                </View>
                <View
                  className={`mr-2 mt-2 rounded-full border px-3 py-1 ${rarityInfo.badgeClass}`}
                >
                  <Text
                    className={`${rarityInfo.textClass} text-xs font-semibold`}
                  >
                    {rarityInfo.label}
                  </Text>
                </View>
                <View
                  className={`mr-2 mt-2 flex-row items-center rounded-full px-3 py-1 ${urgencyInfo.badgeClass}`}
                >
                  <Ionicons
                    name="alarm-outline"
                    size={14}
                    color={urgencyInfo.iconColor}
                  />
                  <Text
                    className={`${urgencyInfo.textClass} ml-2 text-xs font-semibold`}
                  >
                    {urgencyInfo.label}
                  </Text>
                </View>
                {expiresLabel ? (
                  <View
                    className={`mr-2 mt-2 flex-row items-center rounded-full border px-3 py-1 ${soon ? 'border-rose-500/40 bg-rose-500/10' : 'border-slate-700/60 bg-slate-800/70'}`}
                  >
                    <Ionicons
                      name="time-outline"
                      size={14}
                      color={soon ? '#fb7185' : '#cbd5f5'}
                    />
                    <Text
                      className={`ml-2 text-xs font-semibold ${soon ? 'text-rose-200' : 'text-slate-300'}`}
                    >
                      {soon
                        ? `Осталось ${expiresLabel}`
                        : `Срок ${expiresLabel}`}
                    </Text>
                  </View>
                ) : null}
              </View>
            </View>
            <View className="rounded-2xl bg-slate-800/70 px-3 py-1">
              <Text className="text-slate-300 text-sm font-semibold">
                {quest.status === 'active' && 'Активно'}
                {quest.status === 'available' && 'Доступно'}
                {quest.status === 'completed' && 'Завершено'}
              </Text>
            </View>
          </View>

          <View className="mt-4">
            <View className="flex-row items-center">
              <Ionicons name="navigate-outline" size={16} color="#38bdf8" />
              <Text className="ml-2 text-slate-300 text-sm">
                {quest.location}
              </Text>
            </View>
            {quest.faction ? (
              <View className="mt-2 flex-row items-center">
                <Ionicons name="people-outline" size={16} color="#a855f7" />
                <Text className="ml-2 text-slate-400 text-sm">
                  Фракция: {quest.faction}
                </Text>
              </View>
            ) : null}
          </View>

          <Text className="text-slate-400 mt-4 leading-6">
            {quest.description}
          </Text>

          <View className="mt-4 rounded-2xl border border-slate-800/60 bg-slate-900/60 p-4">
            <View className="flex-row items-center">
              <Ionicons name="book-outline" size={16} color="#818cf8" />
              <Text className="text-slate-200 ml-2 text-sm font-semibold">
                Нить истории
              </Text>
            </View>
            <Text className="text-slate-300 mt-2 leading-6">
              {quest.narrativeHook}
            </Text>
            <View className="mt-3">
              {quest.objectives.map((objective, objectiveIndex) => (
                <View
                  key={`${quest.id}-objective-${objectiveIndex}`}
                  className="mt-2 flex-row items-start"
                >
                  <Ionicons name="chevron-forward" size={14} color="#94a3b8" />
                  <Text className="ml-2 flex-1 text-slate-300 text-sm leading-5">
                    {objective}
                  </Text>
                </View>
              ))}
            </View>
          </View>

          <View className="mt-4 flex-row flex-wrap">
            {quest.tags.map((tag, tagIndex) => (
              <View
                key={`${quest.id}-${tag}-${tagIndex}`}
                className="mr-2 mt-2 rounded-full bg-slate-800/70 px-3 py-1"
              >
                <Text className="text-slate-300 text-xs font-semibold">
                  {tagTranslations[tag] ?? tag}
                </Text>
              </View>
            ))}
          </View>

          <View className="mt-4">
            <View className="flex-row items-center justify-between">
              <Text className="text-slate-400 text-sm">Прогресс</Text>
              <View className="flex-row items-center">
                <Ionicons name="barbell-outline" size={14} color="#c084fc" />
                <Text className="ml-2 text-xs text-slate-400">
                  Сложность {quest.challengeRating}
                </Text>
              </View>
              <Text className="text-emerald-300 font-semibold">
                {boundedProgress}/{safeGoal}
              </Text>
            </View>
            <SegmentedProgress
              value={boundedProgress}
              max={safeGoal}
              filledClassName="bg-emerald-500"
            />
          </View>

          <View className="mt-4 flex-row flex-wrap">
            <View className="mr-6 mt-3">
              <View className="flex-row items-center">
                <Ionicons name="star-outline" size={14} color="#38bdf8" />
                <Text className="ml-2 text-slate-500 text-xs uppercase">
                  Опыт
                </Text>
              </View>
              <Text className="mt-1 text-indigo-300 font-semibold">
                {quest.rewardXp}
              </Text>
            </View>
            <View className="mr-6 mt-3">
              <View className="flex-row items-center">
                <Ionicons name="pricetag-outline" size={14} color="#fbbf24" />
                <Text className="ml-2 text-slate-500 text-xs uppercase">
                  Монеты
                </Text>
              </View>
              <Text className="mt-1 text-amber-300 font-semibold">
                {quest.rewardCoins}
              </Text>
            </View>
            {quest.rewardItem ? (
              <View className="mt-3">
                <View className="flex-row items-center">
                  <Ionicons name="cube-outline" size={14} color="#34d399" />
                  <Text className="ml-2 text-slate-500 text-xs uppercase">
                    Трофей
                  </Text>
                </View>
                <Text className="mt-1 text-slate-300 font-semibold">
                  {quest.rewardItem.name}
                </Text>
              </View>
            ) : null}
          </View>

          {renderQuestActions(quest)}
        </View>
      );
    },
    [renderQuestActions],
  );

  return (
    <View className="flex-1 bg-slate-950">
      <ScrollView className="flex-1">
        <View className="px-5 pt-12 pb-6">
          <Text className="text-slate-200 text-2xl font-semibold">
            Журнал заданий
          </Text>
          <Text className="text-slate-400 mt-1">
            Следите за историей Эраэлиона и выбирайте задачи, что ведут к славе.
          </Text>
        </View>

        {toast ? (
          <View
            className={`mx-5 mb-4 rounded-3xl border ${accent.border} ${accent.surface} p-4 ${accent.glow}`}
          >
            <View className="flex-row items-center">
              <Ionicons name="notifications" size={18} color={accent.icon} />
              <Text className={`${accent.text} ml-2`}>{toast}</Text>
            </View>
          </View>
        ) : null}

        <View className="px-5">
          <View
            className={`rounded-3xl border ${accent.border} ${accent.surface} p-5 ${accent.glow}`}
          >
            <View className="flex-row justify-between">
              <View className="items-center">
                <Ionicons name="flame" size={20} color="#f97316" />
                <Text className="text-slate-400 mt-1 text-xs uppercase">
                  Активно
                </Text>
                <Text className="text-slate-200 text-lg font-semibold">
                  {activeQuests.length}
                </Text>
              </View>
              <View className="items-center">
                <Ionicons name="compass" size={20} color="#38bdf8" />
                <Text className="text-slate-400 mt-1 text-xs uppercase">
                  Доступно
                </Text>
                <Text className="text-slate-200 text-lg font-semibold">
                  {availableQuests.length}
                </Text>
              </View>
              <View className="items-center">
                <Ionicons name="ribbon" size={20} color="#34d399" />
                <Text className="text-slate-400 mt-1 text-xs uppercase">
                  Завершено
                </Text>
                <Text className="text-slate-200 text-lg font-semibold">
                  {completedQuests.length}
                </Text>
              </View>
            </View>
          </View>

          <View
            className={`mt-5 rounded-3xl border ${accent.border} bg-slate-900/90 p-5 ${accent.glow}`}
          >
            <View className="flex-row items-start justify-between">
              <View className="flex-1 pr-4">
                <Text className="text-slate-200 text-lg font-semibold">
                  Астральная доска
                </Text>
                <Text className="text-slate-400 mt-1 text-sm">
                  Обновлено: {lastRefreshLabel}
                </Text>
                <Text className="text-slate-500 mt-1 text-xs">
                  Обновлений: {state.questBoardRefreshCount}
                </Text>
                {activeQuests.length > 0 ? (
                  <View className="mt-2 flex-row items-center">
                    <Ionicons
                      name="analytics-outline"
                      size={14}
                      color="#38bdf8"
                    />
                    <Text className="ml-2 text-xs text-slate-400">
                      Средний прогресс активных: {activeCompletion}%
                    </Text>
                  </View>
                ) : null}
              </View>
              <Pressable
                onPress={handleRefreshBoard}
                disabled={isRefreshingBoard}
                className={`flex-row items-center rounded-2xl px-3 py-2 ${isRefreshingBoard ? 'bg-slate-700/40 opacity-70' : 'bg-sky-500/20'}`}
              >
                <Ionicons
                  name="refresh"
                  size={16}
                  color={isRefreshingBoard ? '#94a3b8' : '#38bdf8'}
                />
                <Text
                  className={`ml-2 text-sm font-semibold ${isRefreshingBoard ? 'text-slate-300' : 'text-sky-300'}`}
                >
                  {isRefreshingBoard ? 'Обновляем...' : 'Обновить'}
                </Text>
              </Pressable>
            </View>

            {categorySummary.length > 0 ? (
              <View className="mt-4 flex-row flex-wrap">
                {categorySummary.map((entry) => {
                  const meta = categoryMeta[entry.category];
                  return (
                    <View
                      key={entry.category}
                      className="mr-3 mt-3 rounded-2xl border border-slate-700/60 bg-slate-900/70 px-3 py-2"
                    >
                      <View className="flex-row items-center">
                        <Ionicons
                          name={meta.icon}
                          size={14}
                          color={meta.iconColor}
                        />
                        <Text
                          className={`ml-2 text-xs font-semibold ${meta.textClass}`}
                        >
                          {meta.label}
                        </Text>
                      </View>
                      <View className="mt-2 flex-row">
                        <Text className="text-xs text-slate-400">
                          Всего {entry.total}
                        </Text>
                        <Text className="ml-3 text-xs text-emerald-300">
                          Актив {entry.active}
                        </Text>
                        <Text className="ml-3 text-xs text-sky-300">
                          Доступ {entry.available}
                        </Text>
                      </View>
                    </View>
                  );
                })}
              </View>
            ) : null}

            <View className="mt-4 flex-row flex-wrap">
              <View className="mr-4 flex-row items-center">
                <Ionicons name="alarm-outline" size={14} color="#facc15" />
                <Text className="ml-2 text-xs text-slate-400">
                  Срочных поручений: {expiringSoonCount}
                </Text>
              </View>
              <View className="mt-2 mr-4 flex-row items-center">
                <Ionicons name="book-outline" size={14} color="#818cf8" />
                <Text className="ml-2 text-xs text-slate-400">
                  Активных рассказов: {activeQuests.length}
                </Text>
              </View>
            </View>
          </View>
        </View>

        <View className="px-5 mt-8">
          <Text className="text-slate-200 text-xl font-semibold">
            Активные задания
          </Text>
          {activeQuests.length === 0 ? (
            <View className="mt-4 rounded-3xl border border-slate-700/60 bg-slate-900/80 p-5">
              <Text className="text-slate-500">
                Пока нет активных задач. Выберите цель из доступных, чтобы
                продолжить путь героя.
              </Text>
            </View>
          ) : (
            activeQuests.map((quest, index) => renderQuestCard(quest, index))
          )}
        </View>

        <View className="px-5 mt-8">
          <Text className="text-slate-200 text-xl font-semibold">
            Доступные задания
          </Text>
          {availableQuests.length === 0 ? (
            <View className="mt-4 rounded-3xl border border-slate-700/60 bg-slate-900/80 p-5">
              <Text className="text-slate-500">
                Все возможные задания уже взяты. Завершите текущие миссии, чтобы
                открыть новые пути.
              </Text>
            </View>
          ) : (
            availableQuests.map((quest, index) => renderQuestCard(quest, index))
          )}
        </View>

        <View className="px-5 mt-8">
          <Text className="text-slate-200 text-xl font-semibold">
            Завершенные истории
          </Text>
          {completedQuests.length === 0 ? (
            <View className="mt-4 rounded-3xl border border-slate-700/60 bg-slate-900/80 p-5">
              <Text className="text-slate-500">
                Великая хроника ждет ваших подвигов. Завершайте задания, чтобы
                заполнить этот раздел.
              </Text>
            </View>
          ) : (
            completedQuests.map((quest, index) => renderQuestCard(quest, index))
          )}
        </View>

        <View className="h-16" />
      </ScrollView>
    </View>
  );
}

```

## File: /src/app/(tabs)/shop.tsx
```
import React, { useCallback, useMemo, useRef, useState } from 'react';
import { Image, Pressable, ScrollView, Text, View } from 'react-native';
import Ionicons from '@expo/vector-icons/Ionicons';
import { SegmentedProgress } from '../../components/SegmentedProgress';
import { useHero } from '../../context/HeroContext';
import type { HeroStyleAccent, InventoryItem } from '../../context/HeroContext';
import { accentPalette } from '../../utils/accent';

type ShopCategory = 'weapons' | 'outfits' | 'supplies' | 'artifacts';

type ShopItem = InventoryItem & {
  price: number;
  repeatable?: boolean;
  badge?: string;
  artwork?: string;
};

const shopCatalog: Record<ShopCategory, ShopItem[]> = {
  weapons: [
    {
      id: 'celestial_sabre',
      name: 'Небесная сабля',
      rarity: 'rare',
      type: 'weapon',
      description:
        'Лезвие, напитанное молнией. Увеличивает силу и скорость атаки.',
      value: 140,
      quantity: 1,
      price: 180,
      bonuses: {
        attack: 5,
        agility: 1,
      },
      badge: 'Новинка',
      artwork:
        'https://a.asim.sh/images?query=fantasy+celestial+sword+illustration',
    },
    {
      id: 'ember_halberd',
      name: 'Эмберовый алебард',
      rarity: 'epic',
      type: 'weapon',
      description: 'Глефа клана Ядовитого заката. Излучает пепельное тепло.',
      value: 210,
      quantity: 1,
      price: 260,
      bonuses: {
        attack: 6,
        maxHp: 8,
      },
      artwork: 'https://a.asim.sh/images?query=fantasy+halberd+ember+glow+art',
    },
    {
      id: 'whisper_daggers',
      name: 'Кинжалы шёпота',
      rarity: 'uncommon',
      type: 'weapon',
      description: 'Парные клинки для стремительных атак и точных ударов.',
      value: 95,
      quantity: 1,
      price: 120,
      bonuses: {
        agility: 3,
      },
      artwork:
        'https://a.asim.sh/images?query=fantasy+dual+daggers+shadow+illustration',
    },
    {
      id: 'glacier_staff',
      name: 'Посох ледяной волны',
      rarity: 'rare',
      type: 'weapon',
      description:
        'Кристаллический жезл, усиливающий дальние заклинания и контроль врагов.',
      value: 175,
      quantity: 1,
      price: 210,
      bonuses: {
        attack: 4,
        maxMana: 12,
      },
      artwork: 'https://a.asim.sh/images?query=fantasy+ice+mage+staff+glow',
    },
    {
      id: 'auric_greatbow',
      name: 'Златолучный лук',
      rarity: 'epic',
      type: 'weapon',
      description:
        'Лук, сотканный из солнечных нитей. Стрелы оставляют за собой лучистый след.',
      value: 230,
      quantity: 1,
      price: 285,
      bonuses: {
        attack: 6,
        agility: 3,
      },
      badge: 'Арена',
      artwork:
        'https://a.asim.sh/images?query=fantasy+sunlight+longbow+illustration',
    },
    {
      id: 'echo_blade',
      name: 'Клинок эха',
      rarity: 'legendary',
      type: 'weapon',
      description:
        'Меч, отражающий удары и воспроизводящий силу соперника. Требует мастерства.',
      value: 340,
      quantity: 1,
      price: 420,
      bonuses: {
        attack: 7,
        defense: 2,
        agility: 2,
      },
      artwork:
        'https://a.asim.sh/images?query=fantasy+legendary+sword+echoing+light',
    },
  ],

  outfits: [
    {
      id: 'silk_of_twilight',
      name: 'Шёлк сумерек',
      rarity: 'epic',
      type: 'outfit',
      description: 'Драпировка из теней. Усиливает уклонение и ману.',
      value: 190,
      quantity: 1,
      price: 240,
      bonuses: {
        agility: 4,
        maxMana: 12,
      },
      badge: 'Коллекция дня',
      artwork:
        'https://a.asim.sh/images?query=fantasy+twilight+robe+fashion+art',
    },
    {
      id: 'auric_trousers',
      name: 'Золототканые штаны',
      rarity: 'rare',
      type: 'outfit',
      description: 'Удобный комплект для долгих путешествий.',
      value: 130,
      quantity: 1,
      price: 160,
      bonuses: {
        agility: 2,
        defense: 2,
      },
      artwork:
        'https://a.asim.sh/images?query=fantasy+golden+adventurer+attire',
    },
    {
      id: 'glimmer_brooch',
      name: 'Брошь мерцания',
      rarity: 'uncommon',
      type: 'accessory',
      description: 'Украшение с эхо-зерном, усиливающее поток маны.',
      value: 105,
      quantity: 1,
      price: 140,
      bonuses: {
        maxMana: 10,
      },
      artwork: 'https://a.asim.sh/images?query=fantasy+crystal+brooch+glow',
    },
    {
      id: 'storm_dancer_cape',
      name: 'Плащ танцора грозы',
      rarity: 'rare',
      type: 'outfit',
      description:
        'Электризованный плащ, позволяющий стремительно менять позиции в бою.',
      value: 165,
      quantity: 1,
      price: 210,
      bonuses: {
        agility: 4,
        defense: 1,
      },
      badge: 'Популярно',
      artwork:
        'https://a.asim.sh/images?query=fantasy+storm+cloak+illustration',
    },
    {
      id: 'veil_of_serenity',
      name: 'Вуаль безмятежности',
      rarity: 'epic',
      type: 'outfit',
      description: 'Одежда, впитывающая шум битвы и защищающая разум от хаоса.',
      value: 220,
      quantity: 1,
      price: 275,
      bonuses: {
        maxMana: 12,
        defense: 2,
      },
      artwork:
        'https://a.asim.sh/images?query=fantasy+serene+mage+robe+illustration',
    },
    {
      id: 'radiant_step_sandals',
      name: 'Сандалии сияющего шага',
      rarity: 'uncommon',
      type: 'accessory',
      description:
        'Лёгкая обувь, усиливающая реакцию и ловкость в танце клинков.',
      value: 90,
      quantity: 1,
      price: 126,
      bonuses: {
        agility: 3,
      },
      artwork:
        'https://a.asim.sh/images?query=fantasy+glowing+sandals+illustration',
    },
  ],

  supplies: [
    {
      id: 'panacea_bundle',
      name: 'Набор панакеи',
      rarity: 'rare',
      type: 'consumable',
      description: 'Подборка эликсиров, восполняющих здоровье и ману.',
      value: 40,
      quantity: 1,
      price: 60,
      stackable: true,
      effect: {
        type: 'heal',
        value: 40,
      },
      repeatable: true,
      artwork:
        'https://a.asim.sh/images?query=fantasy+alchemy+elixir+vials+glowing',
    },
    {
      id: 'luminous_ink',
      name: 'Свечение писца',
      rarity: 'uncommon',
      type: 'consumable',
      description:
        'Чернила, усиливающие концентрацию. Восстанавливают 35 маны.',
      value: 34,
      quantity: 1,
      price: 48,
      stackable: true,
      effect: {
        type: 'mana',
        value: 35,
      },
      repeatable: true,
      artwork: 'https://a.asim.sh/images?query=fantasy+ink+vial+arcane+blue',
    },
    {
      id: 'vitality_poultice',
      name: 'Мазь жизненной силы',
      rarity: 'common',
      type: 'consumable',
      description:
        'Смесь целителей северных племён. Восстанавливает 28 здоровья.',
      value: 22,
      quantity: 1,
      price: 32,
      stackable: true,
      effect: {
        type: 'heal',
        value: 28,
      },
      repeatable: true,
      artwork: 'https://a.asim.sh/images?query=fantasy+herbal+salve+glowing',
    },
    {
      id: 'battlefield_rations',
      name: 'Походный рацион арены',
      rarity: 'uncommon',
      type: 'consumable',
      description:
        'Протеиновый набор бойцов. Восстанавливает здоровье и добавляет бодрости.',
      value: 38,
      quantity: 1,
      price: 54,
      stackable: true,
      effect: {
        type: 'heal',
        value: 32,
      },
      repeatable: true,
      artwork:
        'https://a.asim.sh/images?query=fantasy+provisions+satchel+illustration',
    },
    {
      id: 'echo_draught',
      name: 'Зелье эхо-резонанса',
      rarity: 'rare',
      type: 'consumable',
      description:
        'Редкий настой, усиливающий следующий навык или способность.',
      value: 60,
      quantity: 1,
      price: 95,
      stackable: true,
      effect: {
        type: 'buff',
        value: 1,
      },
      artwork:
        'https://a.asim.sh/images?query=fantasy+arcane+potion+violet+illustration',
    },
    {
      id: 'starlit_chart',
      name: 'Астральная карта пути',
      rarity: 'uncommon',
      type: 'quest',
      description:
        'Свиток, приводящий к скрытым событиям. Полезен исследователям.',
      value: 70,
      quantity: 1,
      price: 90,
      artwork:
        'https://a.asim.sh/images?query=fantasy+star+map+scroll+illustration',
    },
  ],

  artifacts: [
    {
      id: 'chorus_charm',
      name: 'Обвес эфира',
      rarity: 'epic',
      type: 'artifact',
      description: 'Астральный талисман, гармонизирующий энергию заклинаний.',
      value: 220,
      quantity: 1,
      price: 270,
      bonuses: {
        maxMana: 14,
        attack: 2,
      },
      artwork: 'https://a.asim.sh/images?query=fantasy+arcane+amulet+glow',
    },
    {
      id: 'guardian_sigil',
      name: 'Печать стража',
      rarity: 'rare',
      type: 'artifact',
      description: 'Символ, укрепляющий защитные ритуалы.',
      value: 150,
      quantity: 1,
      price: 195,
      bonuses: {
        defense: 4,
        maxHp: 10,
      },
      artwork:
        'https://a.asim.sh/images?query=fantasy+guardian+sigil+shield+art',
    },
    {
      id: 'aurora_diadem',
      name: 'Диадема ауроры',
      rarity: 'legendary',
      type: 'accessory',
      description:
        'Венец, отражающий полярное сияние. Усиливает все аспекты героя.',
      value: 320,
      quantity: 1,
      price: 380,
      bonuses: {
        attack: 3,
        defense: 3,
        maxMana: 14,
      },
      badge: 'Редкость',
      artwork:
        'https://a.asim.sh/images?query=fantasy+tiara+aurora+magical+illustration',
    },
    {
      id: 'astral_compass',
      name: 'Астральный компас проводника',
      rarity: 'rare',
      type: 'artifact',
      description: 'Навигатор, указывающий на события и скрытые реликвии.',
      value: 180,
      quantity: 1,
      price: 225,
      bonuses: {
        agility: 2,
        maxMana: 8,
      },
      artwork:
        'https://a.asim.sh/images?query=fantasy+compass+arcane+illustration',
    },
    {
      id: 'wyrm_scale_charm',
      name: 'Чар-знак чешуи дракона',
      rarity: 'epic',
      type: 'artifact',
      description: 'Символ из выветренной чешуи. Поглощает часть урона.',
      value: 260,
      quantity: 1,
      price: 315,
      bonuses: {
        defense: 5,
        maxHp: 18,
      },
      artwork:
        'https://a.asim.sh/images?query=fantasy+dragon+scale+amulet+illustration',
    },
    {
      id: 'shadowed_lantern',
      name: 'Фонарь теней',
      rarity: 'rare',
      type: 'artifact',
      description: 'Освещает скрытые пути и притягивает призрачных союзников.',
      value: 200,
      quantity: 1,
      price: 248,
      bonuses: {
        agility: 2,
        attack: 2,
      },
      badge: 'Гильдия',
      artwork:
        'https://a.asim.sh/images?query=fantasy+lantern+shadow+magic+illustration',
    },
  ],
};

const categoryOptions: Array<{
  key: ShopCategory;
  title: string;
  icon: keyof typeof Ionicons.glyphMap;
}> = [
  { key: 'weapons', title: 'Оружие', icon: 'flash' },
  { key: 'outfits', title: 'Одежда', icon: 'shirt' },
  { key: 'supplies', title: 'Припасы', icon: 'flask' },
  { key: 'artifacts', title: 'Артефакты', icon: 'color-wand' },
];

const marketIllustrations: Record<HeroStyleAccent, string> = {
  emerald:
    'https://a.asim.sh/images?query=fantasy+market+emerald+lanterns+illustration',
  sky: 'https://a.asim.sh/images?query=fantasy+sky+market+blue+glow+illustration',
  violet:
    'https://a.asim.sh/images?query=fantasy+arcane+boutique+violet+lights',
  amber: 'https://a.asim.sh/images?query=fantasy+bazaar+amber+warm+light',
  crimson:
    'https://a.asim.sh/images?query=fantasy+market+crimson+banners+dramatic',
};

const bonusLabels: Record<string, string> = {
  attack: 'Атака',
  defense: 'Защита',
  agility: 'Ловкость',
  maxHp: 'Макс. здоровье',
  maxMana: 'Макс. мана',
};

const rarityColors: Record<InventoryItem['rarity'], string> = {
  common: 'text-slate-400',
  uncommon: 'text-emerald-400',
  rare: 'text-sky-400',
  epic: 'text-violet-400',
  legendary: 'text-amber-400',
};

const formatBonuses = (item: InventoryItem) => {
  if (!item.bonuses) {
    return [];
  }
  const entries: string[] = [];
  Object.keys(item.bonuses).forEach((key) => {
    const value = item.bonuses?.[key as keyof typeof item.bonuses];
    if (typeof value === 'number' && value !== 0) {
      const label = bonusLabels[key] ?? key;
      entries.push(`${label} +${value}`);
    }
  });
  return entries;
};

export default function ShopScreen() {
  const { state, purchaseItem } = useHero();
  const [selectedCategory, setSelectedCategory] =
    useState<ShopCategory>('weapons');
  const [shopMessage, setShopMessage] = useState<string | null>(null);
  const [purchasedIds, setPurchasedIds] = useState<string[]>([]);
  const messageTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const accent = useMemo(
    () => accentPalette[state.styleAccent],
    [state.styleAccent],
  );
  const marketArt = useMemo(
    () => marketIllustrations[state.styleAccent],
    [state.styleAccent],
  );

  const featuredItems = useMemo(() => {
    const highlights: ShopItem[] = [];
    categoryOptions.forEach((option) => {
      const spotlight = shopCatalog[option.key].find((item) => item.badge);
      if (spotlight) {
        highlights.push(spotlight);
      }
    });
    return highlights;
  }, []);

  const visibleItems = shopCatalog[selectedCategory];

  const clearMessageTimeout = useCallback(() => {
    if (messageTimeoutRef.current) {
      clearTimeout(messageTimeoutRef.current);
      messageTimeoutRef.current = null;
    }
  }, []);

  const showMessage = useCallback(
    (text: string, duration = 2400) => {
      clearMessageTimeout();
      setShopMessage(text);
      messageTimeoutRef.current = setTimeout(() => {
        setShopMessage(null);
        messageTimeoutRef.current = null;
      }, duration);
    },
    [clearMessageTimeout],
  );

  const handlePurchase = useCallback(
    (item: ShopItem) => {
      const alreadyBought = !item.repeatable && purchasedIds.includes(item.id);
      if (alreadyBought) {
        showMessage('Предмет уже приобретён.');
        return;
      }
      const { success, message } = purchaseItem(item, item.price);
      showMessage(message);
      if (success && !item.repeatable) {
        setPurchasedIds((prev) => [...prev, item.id]);
      }
    },
    [purchaseItem, purchasedIds, showMessage],
  );

  React.useEffect(() => {
    return () => {
      if (messageTimeoutRef.current) {
        clearTimeout(messageTimeoutRef.current);
      }
    };
  }, []);

  return (
    <View className="flex-1 bg-slate-950">
      <ScrollView className="flex-1">
        <View className="px-5 pt-12 pb-6">
          <Text className="text-slate-200 text-2xl font-semibold">
            Рынок Лирии
          </Text>
          <Text className="text-slate-400 mt-1">
            Торговцы представляют реликвии, ткани и припасы, отражающие тренды
            магических дворов.
          </Text>
        </View>

        <View className="px-5">
          <View
            className={`rounded-3xl border ${accent.border} ${accent.surface} p-5 ${accent.glow}`}
          >
            <View className="flex-row items-center">
              <View className="flex-1 pr-4">
                <Text className="text-slate-400 text-xs uppercase">
                  Баланс монет
                </Text>
                <Text className="text-slate-200 mt-1 text-2xl font-semibold">
                  {state.coins} мон.
                </Text>
                <View className="mt-4">
                  <SegmentedProgress
                    value={Math.min(state.coins, 600)}
                    max={600}
                    filledClassName="bg-sky-500"
                    emptyClassName="bg-slate-800"
                  />
                  <Text className={`${accent.text} mt-2 text-sm`}>
                    До клубной привилегии осталось{' '}
                    {Math.max(0, 600 - state.coins)} монет.
                  </Text>
                </View>
              </View>
              <View className="h-24 w-24 overflow-hidden rounded-3xl bg-slate-900/60">
                <Image
                  source={{ uri: marketArt }}
                  className="h-full w-full"
                  resizeMode="cover"
                />
              </View>
            </View>
          </View>
        </View>

        {shopMessage ? (
          <View
            className={`mx-5 mt-4 rounded-3xl border ${accent.border} ${accent.surface} p-4 ${accent.glow}`}
          >
            <View className="flex-row items-start">
              <Ionicons name="notifications" size={18} color={accent.icon} />
              <Text className={`${accent.text} ml-2 flex-1 leading-6`}>
                {shopMessage}
              </Text>
            </View>
          </View>
        ) : null}

        {featuredItems.length > 0 ? (
          <View className="mt-6">
            <Text className="px-5 text-slate-200 text-xl font-semibold">
              Отмеченные предложения
            </Text>
            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              className="mt-3"
            >
              <View className="flex-row px-5">
                {featuredItems.map((item, index) => {
                  const isSoldOut =
                    !item.repeatable && purchasedIds.includes(item.id);
                  const marginStart = index === 0 ? '' : 'ml-4';
                  const marginEnd =
                    index === featuredItems.length - 1 ? 'mr-5' : 'mr-4';
                  return (
                    <View
                      key={item.id}
                      className={`${marginStart} ${marginEnd} w-64 overflow-hidden rounded-3xl border border-slate-700/60 bg-slate-900/80`}
                    >
                      {item.artwork ? (
                        <Image
                          source={{ uri: item.artwork }}
                          className="h-32 w-full"
                          resizeMode="cover"
                        />
                      ) : null}
                      <View className="p-4">
                        <Text className="text-slate-200 text-base font-semibold">
                          {item.name}
                        </Text>
                        <Text
                          className={`${rarityColors[item.rarity]} mt-1 text-xs font-semibold uppercase`}
                        >
                          {item.rarity}
                        </Text>
                        <Text className="text-slate-500 mt-1 text-sm">
                          {item.description}
                        </Text>
                        {item.badge ? (
                          <View className="mt-2 self-start rounded-full bg-slate-800/70 px-3 py-1">
                            <Text className="text-sky-300 text-xs font-semibold">
                              {item.badge}
                            </Text>
                          </View>
                        ) : null}
                        {item.bonuses ? (
                          <Text className="text-emerald-300 mt-2 text-sm">
                            {formatBonuses(item).join(', ')}
                          </Text>
                        ) : null}
                        <View className="mt-4 flex-row items-center justify-between">
                          <Text className="text-amber-300 text-lg font-semibold">
                            {item.price} мон.
                          </Text>
                          <Pressable
                            onPress={() => handlePurchase(item)}
                            disabled={isSoldOut}
                            className={`rounded-2xl px-4 py-2 ${
                              isSoldOut
                                ? 'bg-slate-800/70'
                                : 'bg-emerald-500/20'
                            }`}
                          >
                            <Text
                              className={
                                isSoldOut
                                  ? 'text-slate-500 font-semibold'
                                  : 'text-emerald-200 font-semibold'
                              }
                            >
                              {isSoldOut ? 'Приобретено' : 'Купить'}
                            </Text>
                          </Pressable>
                        </View>
                      </View>
                    </View>
                  );
                })}
              </View>
            </ScrollView>
          </View>
        ) : null}

        <View className="mt-8">
          <Text className="px-5 text-slate-200 text-xl font-semibold">
            Категории
          </Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            className="mt-3"
          >
            <View className="flex-row px-5">
              {categoryOptions.map((category, index) => {
                const isActive = selectedCategory === category.key;
                return (
                  <Pressable
                    key={category.key}
                    onPress={() => setSelectedCategory(category.key)}
                    className={`${index === 0 ? '' : 'ml-3'} rounded-2xl border px-4 py-2 flex-row items-center ${
                      isActive
                        ? 'bg-sky-500/20 border-sky-400/40'
                        : 'bg-slate-900/80 border-slate-700/60'
                    }`}
                  >
                    <Ionicons
                      name={category.icon}
                      size={16}
                      color={isActive ? accent.icon : '#94a3b8'}
                    />
                    <Text
                      className={`${isActive ? 'text-sky-300' : 'text-slate-400'} ml-2 font-semibold`}
                    >
                      {category.title}
                    </Text>
                  </Pressable>
                );
              })}
            </View>
          </ScrollView>
        </View>

        <View className="px-5 mt-4">
          <Text className="text-slate-200 text-xl font-semibold">
            {
              categoryOptions.find((option) => option.key === selectedCategory)
                ?.title
            }
          </Text>
          {visibleItems.map((item, index) => {
            const isSoldOut =
              !item.repeatable && purchasedIds.includes(item.id);
            return (
              <View
                key={item.id}
                className={`${index === 0 ? 'mt-4' : 'mt-5'} rounded-3xl border border-slate-700/60 bg-slate-900/80 p-5`}
              >
                <View className="flex-row">
                  {item.artwork ? (
                    <View className="mr-4 h-28 w-28 overflow-hidden rounded-2xl bg-slate-800/60">
                      <Image
                        source={{ uri: item.artwork }}
                        className="h-full w-full"
                        resizeMode="cover"
                      />
                    </View>
                  ) : null}
                  <View className="flex-1">
                    <Text className="text-slate-200 text-base font-semibold">
                      {item.name}
                    </Text>
                    <Text
                      className={`${rarityColors[item.rarity]} mt-1 text-xs font-semibold uppercase`}
                    >
                      {item.rarity}
                    </Text>
                    <Text className="text-slate-500 mt-2 text-sm">
                      {item.description}
                    </Text>
                    {item.bonuses ? (
                      <Text className="text-emerald-300 mt-2 text-sm">
                        {formatBonuses(item).join(', ')}
                      </Text>
                    ) : null}
                    {item.effect ? (
                      <Text className="text-slate-400 mt-2 text-sm">
                        Эффект:{' '}
                        {item.effect.type === 'heal' &&
                          `Восстановление ${item.effect.value} здоровья.`}
                        {item.effect.type === 'mana' &&
                          `Восстановление ${item.effect.value} маны.`}
                      </Text>
                    ) : null}
                  </View>
                </View>
                <View className="mt-4 flex-row items-center justify-between">
                  <View className="flex-row items-center">
                    <Ionicons name="pricetag" size={18} color={accent.icon} />
                    <Text className="ml-2 text-amber-300 text-lg font-semibold">
                      {item.price} мон.
                    </Text>
                  </View>
                  <Pressable
                    onPress={() => handlePurchase(item)}
                    disabled={isSoldOut}
                    className={`rounded-2xl px-4 py-2 ${isSoldOut ? 'bg-slate-800/70' : 'bg-sky-500/20'}`}
                  >
                    <Text
                      className={
                        isSoldOut
                          ? 'text-slate-500 font-semibold'
                          : 'text-sky-200 font-semibold'
                      }
                    >
                      {isSoldOut ? 'Приобретено' : 'Купить'}
                    </Text>
                  </Pressable>
                </View>
              </View>
            );
          })}
        </View>

        <View className="h-16" />
      </ScrollView>
    </View>
  );
}

```

## File: /src/components/SegmentedProgress.tsx
```
import React from 'react';
import { View } from 'react-native';

interface SegmentedProgressProps {
  value: number;
  max: number;
  segments?: number;
  filledClassName?: string;
  emptyClassName?: string;
}

export const SegmentedProgress: React.FC<SegmentedProgressProps> = ({
  value,
  max,
  segments = 12,
  filledClassName = 'bg-emerald-500',
  emptyClassName = 'bg-slate-800',
}) => {
  const safeMax = Math.max(1, max);
  const normalized = Math.max(0, Math.min(1, value / safeMax));
  const filledSegments = Math.round(normalized * segments);

  return (
    <View className="flex-row items-center">
      {Array.from({ length: segments }).map((_, index) => (
        <View
          key={index}
          className={`flex-1 h-2 mx-0.5 rounded-full ${index < filledSegments ? filledClassName : emptyClassName}`}
        />
      ))}
    </View>
  );
};

```

## File: /src/context/CommunityContext.tsx
```
import AsyncStorage from '@react-native-async-storage/async-storage';
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import type { InventoryItem } from './HeroContext';

const COMMUNITY_STORAGE_KEY = 'rpg_community_state_v1';
const COMMUNITY_SELF_ID_KEY = 'rpg_community_self_id';

const createSelfMember = (): CommunityMember => ({
  id: createId('user'),
  name: 'Путник',
  guild: 'Отряд странников Эраэлиона',
  accent: '#38bdf8',
  badge: 'Вы',
  avatar: 'https://a.asim.sh/images?query=fantasy+traveler+portrait+sky+light',
});

export type ChatAuthorTone = 'player' | 'system';

export interface CommunityMember {
  id: string;
  name: string;
  guild: string;
  accent: string;
  badge?: string;
  avatar: string;
}

export interface ChatMessage {
  id: string;
  authorId: string;
  author: string;
  guild?: string;
  text: string;
  timestamp: string;
  tone: ChatAuthorTone;
  accent: string;
  isSelf?: boolean;
  badge?: string;
}

export interface MarketListing {
  id: string;
  item: InventoryItem;
  price: number;
  seller: string;
  sellerGuild: string;
  stock: number;
  demand: number;
  expiresAt: string;
  featured?: boolean;
}

export interface LeaderboardEntry {
  id: string;
  name: string;
  title: string;
  rating: number;
  wins: number;
  losses: number;
  draws: number;
  trend: 'up' | 'down' | 'steady';
  streak: number;
  avatar: string;
  guild: string;
  lastUpdated: string;
}

export interface PvPMatchRecord {
  id: string;
  opponentId: string;
  opponentName: string;
  opponentGuild: string;
  result: 'win' | 'loss' | 'draw';
  ratingDelta: number;
  summary: string;
  timestamp: string;
  rewardXp: number;
  rewardCoins: number;
  heroRatingAfter: number;
}

export interface ArenaOpponent {
  id: string;
  name: string;
  guild: string;
  style: string;
  rating: number;
  power: number;
  temperament: string;
  preferredReward: string;
  avatar: string;
  trend: 'up' | 'down' | 'steady';
}

export interface CommunityState {
  chatMessages: ChatMessage[];
  marketplace: MarketListing[];
  leaderboard: LeaderboardEntry[];
  pvpHistory: PvPMatchRecord[];
  arenaOpponents: ArenaOpponent[];
  members: CommunityMember[];
  lastMarketplaceRefresh: string;
  lastArenaRefresh: string;
}

interface RecordBattlePayload {
  opponentId: string;
  heroName: string;
  heroLevel: number;
  heroPower: number;
}

interface RecordBattleResult {
  result: PvPMatchRecord['result'];
  ratingDelta: number;
  summary: string;
  rewardXp: number;
  rewardCoins: number;
  opponentName: string;
  heroRating: number;
  opponentGuild: string;
}

interface CommunityContextValue {
  state: CommunityState;
  isLoaded: boolean;
  roster: CommunityMember[];
  selfProfile: CommunityMember | null;
  sendMessage: (
    author: string,
    text: string,
    options?: { isSelf?: boolean; tone?: ChatAuthorTone },
  ) => void;
  purchaseListing: (
    listingId: string,
  ) => { success: boolean; message: string; listing?: MarketListing };
  refreshMarketplace: () => void;
  recordBattle: (payload: RecordBattlePayload) => RecordBattleResult;
  refreshArenaOpponents: () => void;
}

const createId = (prefix: string) =>
  `${prefix}-${Math.random().toString(16).slice(2, 10)}`;

const cloneInventoryItem = (item: InventoryItem): InventoryItem => ({
  ...item,
  effect: item.effect ? { ...item.effect } : undefined,
  bonuses: item.bonuses ? { ...item.bonuses } : undefined,
});

const playerDirectory: CommunityMember[] = [
  {
    id: 'user-3f8a9c21',
    name: 'Элан Степ',
    guild: 'Гильдия эмпатов',
    accent: '#38bdf8',
    badge: 'Модератор',
    avatar: 'https://a.asim.sh/images?query=fantasy+empath+hero+portrait',
  },
  {
    id: 'user-7bd42e7f',
    name: 'Роун Файр',
    guild: 'Клинки заката',
    accent: '#fb7185',
    badge: 'Дуэлянт',
    avatar: 'https://a.asim.sh/images?query=fantasy+duelist+portrait+sunset',
  },
  {
    id: 'user-a18c4e90',
    name: 'Мираэль Тихая',
    guild: 'Ковен полночных',
    accent: '#a855f7',
    badge: 'Арканист',
    avatar: 'https://a.asim.sh/images?query=fantasy+midnight+mage+portrait',
  },
  {
    id: 'user-4d20b83e',
    name: 'Тарен Холд',
    guild: 'Стражи рубежа',
    accent: '#facc15',
    badge: 'Полководец',
    avatar: 'https://a.asim.sh/images?query=fantasy+commander+portrait',
  },
  {
    id: 'user-90f5cb12',
    name: 'Сэйра Инь',
    guild: 'Синклит светляков',
    accent: '#34d399',
    badge: 'Навигатор',
    avatar: 'https://a.asim.sh/images?query=fantasy+scout+portrait+emerald',
  },
  {
    id: 'user-52ad91ee',
    name: 'Киалис Ран',
    guild: 'Астральный орден',
    accent: '#38bdf8',
    badge: 'Архивариус',
    avatar: 'https://a.asim.sh/images?query=fantasy+astral+sage+portrait',
  },
  {
    id: 'user-0b7e6f44',
    name: 'Далмер Тихогор',
    guild: 'Хартия арбитров',
    accent: '#818cf8',
    badge: 'Аналитик',
    avatar: 'https://a.asim.sh/images?query=fantasy+strategist+portrait+blue',
  },
];

const baseMarketPool: Array<{
  item: InventoryItem;
  priceRange: [number, number];
  seller: string;
  guild: string;
}> = [
  {
    item: {
      id: 'market_lens_of_echoes',
      name: 'Линза эхо-видения',
      rarity: 'rare',
      type: 'artifact',
      description: 'Фокус, позволяющий видеть колебания времени.',
      value: 210,
      quantity: 1,
      bonuses: {
        agility: 2,
        maxMana: 8,
      },
    },
    priceRange: [180, 220],
    seller: 'Ариэн Волнорождённая',
    guild: 'Синклит светляков',
  },
  {
    item: {
      id: 'market_sunforged_plate',
      name: 'Солнечная лами́нария',
      rarity: 'epic',
      type: 'armor',
      description: 'Доспех, выкованный из сплава лучистой меди и эфира.',
      value: 260,
      quantity: 1,
      bonuses: {
        defense: 6,
        maxHp: 16,
      },
    },
    priceRange: [260, 310],
    seller: 'Квирелл Пламенный',
    guild: 'Стражи рубежа',
  },
  {
    item: {
      id: 'market_moonthread_wrap',
      name: 'Лунный кафтан хроникёра',
      rarity: 'rare',
      type: 'outfit',
      description: 'Облачение, усиливающее ясность мысли и ловкость.',
      value: 180,
      quantity: 1,
      bonuses: {
        agility: 3,
        maxMana: 6,
      },
    },
    priceRange: [150, 195],
    seller: 'Эсса Ледяная Хартия',
    guild: 'Архивариусы эфира',
  },
  {
    item: {
      id: 'market_falcon_talons',
      name: 'Когти звёздного сокола',
      rarity: 'epic',
      type: 'weapon',
      description: 'Гибкие лезвия, созданные для стремительных дуэлей.',
      value: 280,
      quantity: 1,
      bonuses: {
        attack: 7,
        agility: 2,
      },
    },
    priceRange: [290, 340],
    seller: 'Лейна Среброглазая',
    guild: 'Клинки заката',
  },
  {
    item: {
      id: 'market_glowstone_cache',
      name: 'Ящик светоноса',
      rarity: 'uncommon',
      type: 'consumable',
      description: 'Коллекция свечений для пополнения маны.',
      value: 45,
      quantity: 3,
      stackable: true,
      effect: {
        type: 'mana',
        value: 28,
      },
    },
    priceRange: [55, 75],
    seller: 'Панира Эйл',
    guild: 'Сфера рек',
  },
  {
    item: {
      id: 'market_chronicle_tokens',
      name: 'Жетоны хроник',
      rarity: 'uncommon',
      type: 'quest',
      description: 'Платы, подтверждающие участие в дипломатических съездах.',
      value: 90,
      quantity: 1,
    },
    priceRange: [85, 105],
    seller: 'Совет Мнемосин',
    guild: 'Дипломаты грозовых земель',
  },
];

const leaderboardSeed: LeaderboardEntry[] = [
  {
    id: 'player-auren',
    name: 'Аурен Шпиль',
    title: 'Мастер арены',
    rating: 1520,
    wins: 38,
    losses: 11,
    draws: 2,
    trend: 'up',
    streak: 4,
    avatar:
      'https://a.asim.sh/images?query=fantasy+warrior+portrait+emerald+light',
    guild: 'Стражи рубежа',
    lastUpdated: new Date().toISOString(),
  },
  {
    id: 'player-nymia',
    name: 'Нимия Льдинка',
    title: 'Голос лезвия',
    rating: 1485,
    wins: 35,
    losses: 13,
    draws: 4,
    trend: 'steady',
    streak: 1,
    avatar: 'https://a.asim.sh/images?query=fantasy+mage+portrait+blue',
    guild: 'Архивариусы эфира',
    lastUpdated: new Date().toISOString(),
  },
  {
    id: 'player-tovan',
    name: 'Тован Рил',
    title: 'Эхо призывателя',
    rating: 1440,
    wins: 32,
    losses: 16,
    draws: 1,
    trend: 'down',
    streak: -2,
    avatar: 'https://a.asim.sh/images?query=fantasy+summoner+portrait',
    guild: 'Ковен полночных',
    lastUpdated: new Date().toISOString(),
  },
  {
    id: 'player-seris',
    name: 'Сэрис Болд',
    title: 'Щит каравана',
    rating: 1395,
    wins: 29,
    losses: 18,
    draws: 2,
    trend: 'steady',
    streak: 0,
    avatar: 'https://a.asim.sh/images?query=fantasy+guardian+portrait',
    guild: 'Орднариаты дорог',
    lastUpdated: new Date().toISOString(),
  },
];

const opponentPool: Array<
  Omit<ArenaOpponent, 'id' | 'rating' | 'power' | 'trend'>
> = [
  {
    name: 'Кассил Нокт',
    guild: 'Клинки заката',
    style: 'Агрессивный дуэлянт',
    temperament: 'безрассудный',
    preferredReward: 'чистая слава',
    avatar: 'https://a.asim.sh/images?query=fantasy+rogue+duelist+portrait',
  },
  {
    name: 'Линаэла Серебрянка',
    guild: 'Астральные певцы',
    style: 'Маг поддержки',
    temperament: 'выдержанный',
    preferredReward: 'редкие артефакты',
    avatar: 'https://a.asim.sh/images?query=fantasy+support+mage+portrait',
  },
  {
    name: 'Брон Скал',
    guild: 'Стражи рубежа',
    style: 'Щитоносец',
    temperament: 'расчётливый',
    preferredReward: 'монеты',
    avatar: 'https://a.asim.sh/images?query=fantasy+tank+warrior+portrait',
  },
  {
    name: 'Эвия Хайленд',
    guild: 'Орден звездного полёта',
    style: 'Воздушный стрелок',
    temperament: 'непредсказуемый',
    preferredReward: 'экзотические ткани',
    avatar: 'https://a.asim.sh/images?query=fantasy+ranger+portrait',
  },
  {
    name: 'Йорин Тиски',
    guild: 'Хартия арбитров',
    style: 'Тактический мечник',
    temperament: 'холодный',
    preferredReward: 'соглашения',
    avatar: 'https://a.asim.sh/images?query=fantasy+strategist+portrait',
  },
];

const sampleChatOpeners: Array<{ playerId: string; text: string }> = [
  {
    playerId: 'user-3f8a9c21',
    text: 'Сегодняшний шторм занёс в гавань сияющий обломок. Кто пойдёт исследовать?',
  },
  {
    playerId: 'user-7bd42e7f',
    text: 'Орден объявил рейтинговый забег. Нужны маги поддержки! Кто в деле?',
  },
  {
    playerId: 'user-a18c4e90',
    text: 'На рынке появилась диадема с резонансом полярной ночи. Стоит ли брать?',
  },
  {
    playerId: 'user-4d20b83e',
    text: 'Вчера на арене видели нового героя. Говорят, клинки пели.',
  },
  {
    playerId: 'user-90f5cb12',
    text: 'Ищу отряд на экспедицию к Плато песен бурь. Нужен следопыт.',
  },
];

const createListing = (
  seed: (typeof baseMarketPool)[number],
): MarketListing => {
  const [minPrice, maxPrice] = seed.priceRange;
  const price = Math.round(minPrice + Math.random() * (maxPrice - minPrice));
  return {
    id: createId('market'),
    item: cloneInventoryItem({
      ...seed.item,
      quantity: seed.item.quantity ?? 1,
    }),
    price,
    seller: seed.seller,
    sellerGuild: seed.guild,
    stock: seed.item.stackable ? (seed.item.quantity ?? 1) : 1,
    demand: Math.round(50 + Math.random() * 50),
    expiresAt: new Date(
      Date.now() + 1000 * 60 * (180 + Math.random() * 240),
    ).toISOString(),
    featured: Math.random() > 0.65,
  };
};

const createOpponent = (): ArenaOpponent => {
  const base = opponentPool[Math.floor(Math.random() * opponentPool.length)];
  const rating = Math.round(1250 + Math.random() * 260);
  const power = Math.round(480 + Math.random() * 260);
  const trendRoll = Math.random();
  const trend: ArenaOpponent['trend'] =
    trendRoll > 0.68 ? 'up' : trendRoll < 0.32 ? 'down' : 'steady';
  return {
    ...base,
    id: createId('opponent'),
    rating,
    power,
    trend,
  };
};

const deriveTitleFromRating = (rating: number) => {
  if (rating >= 1550) {
    return 'Легенда арены';
  }
  if (rating >= 1450) {
    return 'Мастер арены';
  }
  if (rating >= 1350) {
    return 'Тактик дуэлей';
  }
  return 'Участник лиги';
};

const limitArray = <T,>(arr: T[], max: number) =>
  arr.length > max ? arr.slice(arr.length - max) : arr;

const createDefaultCommunityState = (): CommunityState => {
  const roster = playerDirectory.map((member) => ({ ...member }));
  const chatMessages = sampleChatOpeners.map((entry) => {
    const profile =
      roster.find((member) => member.id === entry.playerId) ??
      roster[Math.floor(Math.random() * roster.length)];
    return {
      id: createId('chat'),
      authorId: profile.id,
      author: profile.name,
      guild: profile.guild,
      text: entry.text,
      timestamp: new Date(
        Date.now() - Math.random() * 3600 * 1000,
      ).toISOString(),
      tone: 'player',
      accent: profile.accent,
      badge: profile.badge,
    } satisfies ChatMessage;
  });

  return {
    chatMessages,
    marketplace: Array.from({ length: 6 }, () =>
      createListing(
        baseMarketPool[Math.floor(Math.random() * baseMarketPool.length)],
      ),
    ),
    leaderboard: [...leaderboardSeed],
    pvpHistory: [],
    arenaOpponents: Array.from({ length: 4 }, () => createOpponent()),
    members: roster,
    lastMarketplaceRefresh: new Date().toISOString(),
    lastArenaRefresh: new Date().toISOString(),
  };
};

const normalizeMessage = (raw: any): ChatMessage => {
  const author = typeof raw?.author === 'string' ? raw.author : 'Путник';
  const authorId =
    typeof raw?.authorId === 'string' ? raw.authorId : createId('user');
  const guild =
    typeof raw?.guild === 'string' && raw.guild.length > 0
      ? raw.guild
      : undefined;
  return {
    id: typeof raw?.id === 'string' ? raw.id : createId('chat'),
    author,
    authorId,
    guild,
    text:
      typeof raw?.text === 'string'
        ? raw.text
        : 'Сообщение потеряно во времени.',
    timestamp:
      typeof raw?.timestamp === 'string'
        ? raw.timestamp
        : new Date().toISOString(),
    tone: (raw?.tone as ChatAuthorTone) ?? 'player',
    accent: typeof raw?.accent === 'string' ? raw.accent : '#38bdf8',
    isSelf: Boolean(raw?.isSelf),
    badge: typeof raw?.badge === 'string' ? raw.badge : undefined,
  };
};

const normalizeListing = (raw: any): MarketListing => {
  const item = raw?.item
    ? cloneInventoryItem({
        ...raw.item,
        quantity: raw.item?.quantity ?? 1,
      })
    : cloneInventoryItem(baseMarketPool[0].item);
  return {
    id: typeof raw?.id === 'string' ? raw.id : createId('market'),
    item,
    price: typeof raw?.price === 'number' ? raw.price : 120,
    seller:
      typeof raw?.seller === 'string' ? raw.seller : 'Неизвестный торговец',
    sellerGuild:
      typeof raw?.sellerGuild === 'string'
        ? raw.sellerGuild
        : 'Незарегистрированная гильдия',
    stock: typeof raw?.stock === 'number' ? raw.stock : 1,
    demand: typeof raw?.demand === 'number' ? raw.demand : 60,
    expiresAt:
      typeof raw?.expiresAt === 'string'
        ? raw.expiresAt
        : new Date(Date.now() + 4 * 3600 * 1000).toISOString(),
    featured: Boolean(raw?.featured),
  };
};

const normalizeLeaderboardEntry = (raw: any): LeaderboardEntry => ({
  id: typeof raw?.id === 'string' ? raw.id : createId('rank'),
  name: typeof raw?.name === 'string' ? raw.name : 'Игрок',
  title: typeof raw?.title === 'string' ? raw.title : 'Участник лиги',
  rating: typeof raw?.rating === 'number' ? raw.rating : 1320,
  wins: typeof raw?.wins === 'number' ? raw.wins : 10,
  losses: typeof raw?.losses === 'number' ? raw.losses : 5,
  draws: typeof raw?.draws === 'number' ? raw.draws : 0,
  trend: (raw?.trend as LeaderboardEntry['trend']) ?? 'steady',
  streak: typeof raw?.streak === 'number' ? raw.streak : 0,
  avatar:
    typeof raw?.avatar === 'string'
      ? raw.avatar
      : 'https://a.asim.sh/images?query=fantasy+player+portrait',
  guild: typeof raw?.guild === 'string' ? raw.guild : 'Гильдия без названия',
  lastUpdated:
    typeof raw?.lastUpdated === 'string'
      ? raw.lastUpdated
      : new Date().toISOString(),
});

const normalizeMatch = (raw: any): PvPMatchRecord => ({
  id: typeof raw?.id === 'string' ? raw.id : createId('match'),
  opponentId:
    typeof raw?.opponentId === 'string' ? raw.opponentId : createId('opponent'),
  opponentName:
    typeof raw?.opponentName === 'string' ? raw.opponentName : 'Противник',
  opponentGuild:
    typeof raw?.opponentGuild === 'string'
      ? raw.opponentGuild
      : 'Неизвестный легион',
  result: (raw?.result as PvPMatchRecord['result']) ?? 'draw',
  ratingDelta: typeof raw?.ratingDelta === 'number' ? raw.ratingDelta : 0,
  summary:
    typeof raw?.summary === 'string' ? raw.summary : 'Сводка недоступна.',
  timestamp:
    typeof raw?.timestamp === 'string'
      ? raw.timestamp
      : new Date().toISOString(),
  rewardXp: typeof raw?.rewardXp === 'number' ? raw.rewardXp : 60,
  rewardCoins: typeof raw?.rewardCoins === 'number' ? raw.rewardCoins : 40,
  heroRatingAfter:
    typeof raw?.heroRatingAfter === 'number' ? raw.heroRatingAfter : 1320,
});

const normalizeMember = (raw: any): CommunityMember => ({
  id: typeof raw?.id === 'string' ? raw.id : createId('user'),
  name: typeof raw?.name === 'string' ? raw.name : 'Игрок',
  guild:
    typeof raw?.guild === 'string' && raw.guild.length > 0
      ? raw.guild
      : 'Независимые искатели',
  accent: typeof raw?.accent === 'string' ? raw.accent : '#94a3b8',
  badge: typeof raw?.badge === 'string' ? raw.badge : undefined,
  avatar:
    typeof raw?.avatar === 'string'
      ? raw.avatar
      : 'https://a.asim.sh/images?query=fantasy+adventurer+portrait+neutral',
});

const normalizeOpponent = (raw: any): ArenaOpponent => ({
  id: typeof raw?.id === 'string' ? raw.id : createId('opponent'),
  name: typeof raw?.name === 'string' ? raw.name : 'Гость арены',
  guild: typeof raw?.guild === 'string' ? raw.guild : 'Путники',
  style: typeof raw?.style === 'string' ? raw.style : 'Дуэлянт',
  rating: typeof raw?.rating === 'number' ? raw.rating : 1320,
  power: typeof raw?.power === 'number' ? raw.power : 520,
  temperament:
    typeof raw?.temperament === 'string' ? raw.temperament : 'непредсказуемый',
  preferredReward:
    typeof raw?.preferredReward === 'string' ? raw.preferredReward : 'слава',
  avatar:
    typeof raw?.avatar === 'string'
      ? raw.avatar
      : 'https://a.asim.sh/images?query=fantasy+arena+opponent+portrait',
  trend: (raw?.trend as ArenaOpponent['trend']) ?? 'steady',
});

const migrateCommunityState = (raw: any): CommunityState => {
  const fallback = createDefaultCommunityState();
  if (!raw) {
    return fallback;
  }

  const baseMembers = Array.isArray(raw.members)
    ? raw.members.map((member: any) => normalizeMember(member)).slice(0, 36)
    : [...fallback.members];

  const chatMessages = Array.isArray(raw.chatMessages)
    ? raw.chatMessages.map((msg: any) => normalizeMessage(msg)).slice(-60)
    : fallback.chatMessages;

  const memberMap = new Map<string, CommunityMember>();
  baseMembers.forEach((member) => {
    memberMap.set(member.id, member);
  });
  chatMessages.forEach((message) => {
    if (!memberMap.has(message.authorId)) {
      memberMap.set(message.authorId, {
        id: message.authorId,
        name: message.author,
        guild: message.guild ?? 'Независимые искатели',
        accent: message.accent,
        badge: message.badge,
        avatar:
          'https://a.asim.sh/images?query=fantasy+adventurer+portrait+neutral',
      });
    }
  });

  return {
    chatMessages,
    marketplace: Array.isArray(raw.marketplace)
      ? raw.marketplace
          .map((listing: any) => normalizeListing(listing))
          .slice(0, 12)
      : fallback.marketplace,
    leaderboard: Array.isArray(raw.leaderboard)
      ? raw.leaderboard
          .map((entry: any) => normalizeLeaderboardEntry(entry))
          .slice(0, 10)
      : fallback.leaderboard,
    pvpHistory: Array.isArray(raw.pvpHistory)
      ? raw.pvpHistory.map((match: any) => normalizeMatch(match)).slice(-20)
      : fallback.pvpHistory,
    arenaOpponents: Array.isArray(raw.arenaOpponents)
      ? raw.arenaOpponents.map((op: any) => normalizeOpponent(op)).slice(0, 6)
      : fallback.arenaOpponents,
    members: Array.from(memberMap.values()).slice(0, 40),
    lastMarketplaceRefresh:
      typeof raw.lastMarketplaceRefresh === 'string'
        ? raw.lastMarketplaceRefresh
        : fallback.lastMarketplaceRefresh,
    lastArenaRefresh:
      typeof raw.lastArenaRefresh === 'string'
        ? raw.lastArenaRefresh
        : fallback.lastArenaRefresh,
  };
};

const CommunityContext = createContext<CommunityContextValue | undefined>(
  undefined,
);

export const CommunityProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [state, setState] = useState<CommunityState>(
    createDefaultCommunityState(),
  );
  const [isLoaded, setIsLoaded] = useState(false);
  const loadingRef = useRef(false);
  const [selfProfile, setSelfProfile] = useState<CommunityMember | null>(null);

  const updateState = useCallback(
    (updater: (prev: CommunityState) => CommunityState) => {
      setState((prev) => updater(prev));
    },
    [],
  );

  useEffect(() => {
    const load = async () => {
      if (loadingRef.current) {
        return;
      }
      loadingRef.current = true;
      try {
        const raw = await AsyncStorage.getItem(COMMUNITY_STORAGE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          const migrated = migrateCommunityState(parsed);
          setState(migrated);
        }
      } catch (error) {
        console.warn('Не удалось загрузить сетевое состояние', error);
      } finally {
        setIsLoaded(true);
        loadingRef.current = false;
      }
    };

    void load();
  }, []);

  useEffect(() => {
    if (!isLoaded) {
      return;
    }
    const persist = async () => {
      try {
        await AsyncStorage.setItem(
          COMMUNITY_STORAGE_KEY,
          JSON.stringify(state),
        );
      } catch (error) {
        console.warn('Не удалось сохранить сетевое состояние', error);
      }
    };

    void persist();
  }, [state, isLoaded]);

  useEffect(() => {
    const ensureSelfProfile = async () => {
      if (!isLoaded) {
        return;
      }
      try {
        const storedId = await AsyncStorage.getItem(COMMUNITY_SELF_ID_KEY);
        let profile = storedId
          ? state.members.find((member) => member.id === storedId)
          : undefined;
        if (!profile) {
          const generated = createSelfMember();
          profile = generated;
          await AsyncStorage.setItem(COMMUNITY_SELF_ID_KEY, generated.id);
          updateState((prev) => {
            if (prev.members.some((member) => member.id === generated.id)) {
              return prev;
            }
            return {
              ...prev,
              members: [...prev.members, generated],
            };
          });
        }
        setSelfProfile(profile);
      } catch (error) {
        console.warn('Не удалось инициализировать профиль игрока', error);
        if (!selfProfile) {
          const fallbackProfile = createSelfMember();
          setSelfProfile(fallbackProfile);
          void AsyncStorage.setItem(
            COMMUNITY_SELF_ID_KEY,
            fallbackProfile.id,
          ).catch(() => {});
          updateState((prev) => {
            if (
              prev.members.some((member) => member.id === fallbackProfile.id)
            ) {
              return prev;
            }
            return {
              ...prev,
              members: [...prev.members, fallbackProfile],
            };
          });
        }
      }
    };

    void ensureSelfProfile();
  }, [isLoaded, selfProfile, state.members, updateState]);

  const sendMessage = useCallback<CommunityContextValue['sendMessage']>(
    (author, text, options) => {
      const trimmed = text.trim();
      if (!trimmed) {
        return;
      }

      const isSelf = options?.isSelf ?? false;
      let ensuredSelf = selfProfile;

      if (isSelf && !ensuredSelf) {
        const generated = createSelfMember();
        ensuredSelf = generated;
        setSelfProfile(generated);
        void AsyncStorage.setItem(COMMUNITY_SELF_ID_KEY, generated.id).catch(
          () => {},
        );
        updateState((prev) => {
          if (prev.members.some((member) => member.id === generated.id)) {
            return prev;
          }
          return {
            ...prev,
            members: [...prev.members, generated],
          };
        });
      }

      if (isSelf && ensuredSelf && ensuredSelf.name !== author) {
        ensuredSelf = { ...ensuredSelf, name: author };
        setSelfProfile(ensuredSelf);
      }

      updateState((prev) => {
        let members = prev.members;
        let member: CommunityMember | undefined;

        if (isSelf && ensuredSelf) {
          if (
            members.some(
              (entry) =>
                entry.id === ensuredSelf.id && entry.name !== ensuredSelf.name,
            )
          ) {
            members = members.map((entry) =>
              entry.id === ensuredSelf.id
                ? { ...entry, name: ensuredSelf.name }
                : entry,
            );
          }
          member = ensuredSelf;
        } else {
          member = members.find((entry) => entry.name === author);
        }

        if (!member) {
          const newMember: CommunityMember = {
            id: createId('user'),
            name: author,
            guild: 'Независимые искатели',
            accent: '#94a3b8',
            badge: undefined,
            avatar:
              'https://a.asim.sh/images?query=fantasy+adventurer+portrait+neutral',
          };
          members = [...members, newMember];
          member = newMember;
        }

        const chatMessages = limitArray(
          [
            ...prev.chatMessages,
            {
              id: createId('chat'),
              author: member.name,
              authorId: member.id,
              guild: member.guild,
              text: trimmed,
              timestamp: new Date().toISOString(),
              tone: options?.tone ?? 'player',
              accent: member.accent,
              isSelf: isSelf && member.id === ensuredSelf?.id,
              badge: member.badge,
            },
          ],
          60,
        );

        return {
          ...prev,
          members,
          chatMessages,
        };
      });
    },
    [selfProfile, updateState],
  );

  const refreshMarketplace = useCallback(() => {
    updateState((prev) => ({
      ...prev,
      marketplace: Array.from({ length: 6 }, () =>
        createListing(
          baseMarketPool[Math.floor(Math.random() * baseMarketPool.length)],
        ),
      ),
      lastMarketplaceRefresh: new Date().toISOString(),
    }));
  }, [updateState]);

  const purchaseListing = useCallback<CommunityContextValue['purchaseListing']>(
    (listingId) => {
      let selected: MarketListing | undefined;
      let message = 'Запись не найдена.';
      let success = false;
      updateState((prev) => {
        const index = prev.marketplace.findIndex(
          (listing) => listing.id === listingId,
        );
        if (index === -1) {
          message = 'Лот уже снят с торгов.';
          return prev;
        }
        const listing = prev.marketplace[index];
        if (listing.stock <= 0) {
          message = 'Товар закончился.';
          return prev;
        }
        success = true;
        selected = {
          ...listing,
          item: cloneInventoryItem(listing.item),
        };
        message = `Вы заключили сделку с ${listing.seller}.`;
        const updatedListing = {
          ...listing,
          stock: listing.stock - 1,
          demand: Math.max(20, listing.demand - 8),
        };
        const marketplace = [...prev.marketplace];
        if (updatedListing.stock <= 0) {
          marketplace.splice(index, 1);
        } else {
          marketplace[index] = updatedListing;
        }
        return {
          ...prev,
          marketplace,
        };
      });

      return { success, message, listing: selected };
    },
    [updateState],
  );

  const integrateHeroToLeaderboard = useCallback(
    (
      board: LeaderboardEntry[],
      heroName: string,
    ): [LeaderboardEntry[], LeaderboardEntry] => {
      const heroId = 'hero-main-entry';
      const existingIndex = board.findIndex((entry) => entry.id === heroId);
      if (existingIndex !== -1) {
        const entry = {
          ...board[existingIndex],
          name: heroName,
        };
        const updated = [...board];
        updated[existingIndex] = entry;
        return [updated, entry];
      }
      const entry: LeaderboardEntry = {
        id: heroId,
        name: heroName,
        title: 'Участник лиги',
        rating: 1320,
        wins: 0,
        losses: 0,
        draws: 0,
        trend: 'steady',
        streak: 0,
        avatar: 'https://a.asim.sh/images?query=fantasy+hero+portrait',
        guild: 'Отряд странников Эраэлиона',
        lastUpdated: new Date().toISOString(),
      };
      return [[...board, entry], entry];
    },
    [],
  );

  const updateOpponentEntry = useCallback(
    (
      board: LeaderboardEntry[],
      opponent: ArenaOpponent,
      ratingDelta: number,
      result: PvPMatchRecord['result'],
    ): LeaderboardEntry[] => {
      const existingIndex = board.findIndex(
        (entry) => entry.name === opponent.name,
      );
      if (existingIndex === -1) {
        const newEntry: LeaderboardEntry = {
          id: opponent.id,
          name: opponent.name,
          title: deriveTitleFromRating(opponent.rating),
          rating: Math.max(1000, opponent.rating - ratingDelta),
          wins: result === 'loss' ? 1 : 0,
          losses: result === 'win' ? 1 : 0,
          draws: result === 'draw' ? 1 : 0,
          trend: ratingDelta < 0 ? 'down' : ratingDelta > 0 ? 'up' : 'steady',
          streak: result === 'loss' ? 1 : result === 'win' ? -1 : 0,
          avatar: opponent.avatar,
          guild: opponent.guild,
          lastUpdated: new Date().toISOString(),
        };
        return [...board, newEntry];
      }
      const entry = { ...board[existingIndex] };
      entry.rating = Math.max(980, entry.rating - ratingDelta);
      if (result === 'win') {
        entry.losses += 1;
        entry.streak = entry.streak > 0 ? -1 : entry.streak - 1;
        entry.trend = 'down';
      } else if (result === 'loss') {
        entry.wins += 1;
        entry.streak = entry.streak >= 0 ? entry.streak + 1 : 1;
        entry.trend = 'up';
      } else {
        entry.draws += 1;
        entry.trend = 'steady';
        entry.streak = 0;
      }
      entry.title = deriveTitleFromRating(entry.rating);
      entry.lastUpdated = new Date().toISOString();
      const updated = [...board];
      updated[existingIndex] = entry;
      return updated;
    },
    [],
  );

  const recordBattle = useCallback<CommunityContextValue['recordBattle']>(
    ({ opponentId, heroName, heroLevel, heroPower }) => {
      let result: PvPMatchRecord['result'] = 'draw';
      let ratingDelta = 0;
      let rewardXp = 60;
      let rewardCoins = 45;
      let opponentName = 'Противник';
      let opponentGuild = 'Лига';
      let heroRatingAfter = 1320;

      updateState((prev) => {
        const opponent =
          prev.arenaOpponents.find((entry) => entry.id === opponentId) ??
          prev.arenaOpponents[0];
        if (!opponent) {
          return prev;
        }
        const opponentPower = opponent.power;
        opponentName = opponent.name;
        opponentGuild = opponent.guild;

        const heroBaseChance =
          0.5 +
          (heroPower - opponentPower) /
            Math.max(240, heroPower + opponentPower + 1);
        const boundedChance = Math.min(0.88, Math.max(0.12, heroBaseChance));
        const dice = Math.random();

        if (dice < boundedChance - 0.1) {
          result = 'win';
          ratingDelta = Math.round(18 + Math.random() * 14 + heroLevel * 0.6);
          rewardXp = Math.round(90 + Math.random() * 40);
          rewardCoins = Math.round(70 + Math.random() * 35);
        } else if (dice > boundedChance + 0.15) {
          result = 'loss';
          ratingDelta = -Math.round(14 + Math.random() * 12);
          rewardXp = Math.round(55 + Math.random() * 25);
          rewardCoins = Math.round(40 + Math.random() * 25);
        } else {
          result = 'draw';
          ratingDelta = Math.round(-4 + Math.random() * 10);
          rewardXp = Math.round(70 + Math.random() * 20);
          rewardCoins = Math.round(50 + Math.random() * 20);
        }

        const [withHero, heroEntry] = integrateHeroToLeaderboard(
          prev.leaderboard,
          heroName,
        );
        const updatedHero = { ...heroEntry };
        updatedHero.rating = Math.max(960, updatedHero.rating + ratingDelta);
        if (result === 'win') {
          updatedHero.wins += 1;
          updatedHero.streak =
            updatedHero.streak >= 0 ? updatedHero.streak + 1 : 1;
          updatedHero.trend = 'up';
        } else if (result === 'loss') {
          updatedHero.losses += 1;
          updatedHero.streak =
            updatedHero.streak <= 0 ? updatedHero.streak - 1 : -1;
          updatedHero.trend = 'down';
        } else {
          updatedHero.draws += 1;
          updatedHero.streak = 0;
          updatedHero.trend = 'steady';
        }
        updatedHero.title = deriveTitleFromRating(updatedHero.rating);
        updatedHero.lastUpdated = new Date().toISOString();
        heroRatingAfter = updatedHero.rating;

        const heroIndex = withHero.findIndex(
          (entry) => entry.id === updatedHero.id,
        );
        const leaderboard = [...withHero];
        leaderboard[heroIndex] = updatedHero;

        const updatedLeaderboard = updateOpponentEntry(
          leaderboard,
          opponent,
          ratingDelta,
          result,
        );

        const match: PvPMatchRecord = {
          id: createId('match'),
          opponentId: opponent.id,
          opponentName: opponent.name,
          opponentGuild: opponent.guild,
          result,
          ratingDelta,
          summary: `Дуэль против ${opponent.name} (${opponent.guild}) завершилась ${result === 'win' ? 'победой' : result === 'loss' ? 'поражением' : 'ничьей'}.`,
          timestamp: new Date().toISOString(),
          rewardXp,
          rewardCoins,
          heroRatingAfter,
        };

        const updatedOpponents = prev.arenaOpponents.map((entry) =>
          entry.id === opponent.id
            ? {
                ...entry,
                rating: Math.max(980, entry.rating - ratingDelta),
                power: Math.max(
                  420,
                  entry.power + Math.round(Math.random() * 20 - 10),
                ),
                trend:
                  ratingDelta > 0 ? 'down' : ratingDelta < 0 ? 'up' : 'steady',
              }
            : entry,
        );

        return {
          ...prev,
          leaderboard: updatedLeaderboard,
          pvpHistory: limitArray([...prev.pvpHistory, match], 20),
          arenaOpponents: updatedOpponents,
          lastArenaRefresh: new Date().toISOString(),
        };
      });

      const summaryMap: Record<PvPMatchRecord['result'], string> = {
        win: `Вы одержали верх над ${opponentName}. Зрители скандируют ваше имя!`,
        loss: `${opponentName} взял реванш, но вы получили бесценный опыт.`,
        draw: `Вы и ${opponentName} разошлись вничью. Рейтинг почти не изменился.`,
      };

      return {
        result,
        ratingDelta,
        summary: summaryMap[result],
        rewardXp,
        rewardCoins,
        opponentName,
        heroRating: heroRatingAfter,
        opponentGuild,
      };
    },
    [integrateHeroToLeaderboard, updateOpponentEntry, updateState],
  );

  const refreshArenaOpponents = useCallback(() => {
    updateState((prev) => ({
      ...prev,
      arenaOpponents: Array.from({ length: 4 }, () => createOpponent()),
      lastArenaRefresh: new Date().toISOString(),
    }));
  }, [updateState]);

  const value = useMemo<CommunityContextValue>(
    () => ({
      state,
      isLoaded,
      roster: state.members,
      selfProfile,
      sendMessage,
      purchaseListing,
      refreshMarketplace,
      recordBattle,
      refreshArenaOpponents,
    }),
    [
      state,
      isLoaded,
      selfProfile,
      sendMessage,
      purchaseListing,
      refreshMarketplace,
      recordBattle,
      refreshArenaOpponents,
    ],
  );

  return (
    <CommunityContext.Provider value={value}>
      {children}
    </CommunityContext.Provider>
  );
};

export const useCommunity = () => {
  const context = useContext(CommunityContext);
  if (!context) {
    throw new Error('useCommunity must be used within CommunityProvider');
  }
  return context;
};

```

## File: /src/context/HeroContext.tsx
```
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import Ionicons from '@expo/vector-icons/Ionicons';
import { generateQuest, generateQuestBatch } from '../utils/questGenerator';
import type {
  QuestCategory,
  QuestRarity,
  QuestUrgency,
} from '../utils/questGenerator';

const HERO_STORAGE_KEY = 'rpg_hero_state_v1';

export type AttributeStat =
  | 'attack'
  | 'defense'
  | 'agility'
  | 'maxHp'
  | 'maxMana';

type ItemEffectType = 'heal' | 'mana' | 'buff' | 'quest';

export type QuestStatus = 'available' | 'active' | 'completed';

export type EquipmentSlot = 'weapon' | 'armor' | 'outfit' | 'accessory';

export type HeroStyleAccent =
  | 'emerald'
  | 'sky'
  | 'violet'
  | 'amber'
  | 'crimson';

export interface ItemEffect {
  type: ItemEffectType;
  value: number;
  stat?: Exclude<AttributeStat, 'maxHp' | 'maxMana'>;
}

export type InventoryItem = {
  id: string;
  name: string;
  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';
  type:
    | 'weapon'
    | 'armor'
    | 'consumable'
    | 'artifact'
    | 'quest'
    | 'outfit'
    | 'accessory';
  description: string;
  value: number;
  quantity: number;
  stackable?: boolean;
  effect?: ItemEffect;
  bonuses?: Partial<Record<AttributeStat, number>>;
};

export type Quest = {
  id: string;
  title: string;
  description: string;
  status: QuestStatus;
  progress: number;
  goal: number;
  tags: string[];
  rewardXp: number;
  rewardCoins: number;
  rewardItem?: InventoryItem;
  category: QuestCategory;
  rarity: QuestRarity;
  urgency: QuestUrgency;
  location: string;
  narrativeHook: string;
  objectives: string[];
  generatedAt: string;
  expiresAt?: string;
  challengeRating: number;
  faction?: string;
};

export type TravelDifficulty = 'story' | 'adventure' | 'mythic';

export type DailyGoalTag = 'battle' | 'explore' | 'shopping' | 'training';

export interface DailyGoal {
  id: string;
  title: string;
  description: string;
  tag: DailyGoalTag;
  progress: number;
  goal: number;
  rewardXp: number;
  rewardCoins: number;
  completed: boolean;
  claimed: boolean;
}

export interface Achievement {
  id: string;
  title: string;
  description: string;
  icon: keyof typeof Ionicons.glyphMap;
  unlocked: boolean;
}

export interface HeroStats {
  battlesWon: number;
  eventsCompleted: number;
  treasuresOpened: number;
  purchasesMade: number;
  trainingsCompleted: number;
  dailyGoalsClaimed: number;
  totalCoinsSpent: number;
}

export type Equipment = {
  weapon?: InventoryItem;
  armor?: InventoryItem;
  outfit?: InventoryItem;
  accessory?: InventoryItem;
};

export interface HeroState {
  name: string;
  archetype: string;
  level: number;
  xp: number;
  xpForNext: number;
  hp: number;
  maxHp: number;
  mana: number;
  maxMana: number;
  attack: number;
  defense: number;
  agility: number;
  coins: number;
  skillPoints: number;
  relics: string[];
  inventory: InventoryItem[];
  quests: Quest[];
  equipment: Equipment;
  travelDifficulty: TravelDifficulty;
  dailyGoals: DailyGoal[];
  achievements: Achievement[];
  stats: HeroStats;
  styleAccent: HeroStyleAccent;
  questBoardLastRefresh: string;
  questBoardRefreshCount: number;
  lastUpdated: string;
}

interface HeroContextValue {
  state: HeroState;
  isLoaded: boolean;
  gainXp: (amount: number) => void;
  takeDamage: (amount: number) => void;
  restoreHealth: (amount: number) => void;
  spendMana: (amount: number) => boolean;
  restoreMana: (amount: number) => void;
  addInventoryItem: (item: InventoryItem) => void;
  useConsumable: (itemId: string) => { success: boolean; message: string };
  earnCoins: (amount: number) => void;
  spendCoins: (amount: number) => boolean;
  acceptQuest: (questId: string) => void;
  completeQuest: (questId: string) => { success: boolean; message: string };
  advanceQuest: (tag: string, amount: number) => void;
  refreshQuestBoard: (
    mode?: 'full' | 'topUp',
  ) => { added: number; message: string };
  longRest: () => void;
  increaseAttribute: (
    stat: AttributeStat,
  ) => { success: boolean; message: string };
  revive: () => void;
  resetHero: () => void;
  equipItem: (itemId: string) => { success: boolean; message: string };
  unequipItem: (slot: EquipmentSlot) => { success: boolean; message: string };
  purchaseItem: (
    item: InventoryItem,
    cost: number,
  ) => { success: boolean; message: string };
  setStyleAccent: (accent: HeroStyleAccent) => void;
  setTravelDifficulty: (difficulty: TravelDifficulty) => void;
  updateDailyGoal: (tag: DailyGoalTag, amount?: number) => void;
  claimDailyGoal: (goalId: string) => { success: boolean; message: string };
  resetDailyGoals: () => void;
  trainDiscipline: (
    stat: AttributeStat,
  ) => { success: boolean; message: string };
  trackHeroStat: (increments: Partial<Record<keyof HeroStats, number>>) => void;
}

const cloneItem = (item: InventoryItem): InventoryItem => ({
  ...item,
  effect: item.effect ? { ...item.effect } : undefined,
  bonuses: item.bonuses ? { ...item.bonuses } : undefined,
});

const cloneQuest = (quest: Quest): Quest => ({
  ...quest,
  rewardItem: quest.rewardItem ? cloneItem(quest.rewardItem) : undefined,
});

const sanitizeQuest = (quest: Quest): Quest => {
  const goal = Math.max(1, quest.goal);
  const progress = Math.max(0, Math.min(goal, quest.progress));
  const status: QuestStatus =
    quest.status === 'completed'
      ? 'completed'
      : quest.status === 'active'
        ? 'active'
        : 'available';
  return cloneQuest({
    ...quest,
    goal,
    progress,
    status,
  });
};

const rebuildQuestBoard = (
  baseState: HeroState,
  mutatedQuests: Quest[],
  options?: {
    replaceAvailable?: boolean;
    targetAvailable?: number;
    minAvailable?: number;
  },
) => {
  const replaceAvailable = options?.replaceAvailable ?? false;
  const targetAvailable = options?.targetAvailable ?? TARGET_AVAILABLE_QUESTS;
  const minAvailable = options?.minAvailable ?? MIN_AVAILABLE_QUESTS;
  const target = Math.max(minAvailable, targetAvailable);

  const active: Quest[] = [];
  const available: Quest[] = [];
  const completed: Quest[] = [];
  const idSet = new Set<string>();

  mutatedQuests.forEach((quest) => {
    const sanitized = sanitizeQuest(quest);
    if (sanitized.status === 'active') {
      active.push(sanitized);
      idSet.add(sanitized.id);
      return;
    }
    if (sanitized.status === 'completed') {
      completed.push(sanitized);
      idSet.add(sanitized.id);
      return;
    }
    available.push({ ...sanitized, status: 'available' });
  });

  const pool: Quest[] = replaceAvailable ? [] : [...available];
  pool.forEach((quest) => idSet.add(quest.id));

  let added = 0;
  while (pool.length < target) {
    const newQuest = generateQuest({
      heroLevel: baseState.level,
      travelDifficulty: baseState.travelDifficulty,
      existingIds: idSet,
      seedOffset: baseState.questBoardRefreshCount + added,
    });
    pool.push(newQuest);
    idSet.add(newQuest.id);
    added += 1;
  }

  const quests = [...active, ...pool, ...completed].map(cloneQuest);
  const refreshedAt = added > 0 ? new Date().toISOString() : undefined;

  return { quests, added, refreshedAt };
};

const defaultEquipmentSeed: Equipment = {
  weapon: {
    id: 'aether_blade',
    name: 'Эфирный клинок',
    rarity: 'uncommon',
    type: 'weapon',
    description:
      'Лезвие, резонирующее с потоками астрала. Повышает атакующую мощь.',
    value: 90,
    quantity: 1,
    bonuses: {
      attack: 4,
    },
  },
  armor: {
    id: 'shadowguard_mail',
    name: 'Доспех тенестража',
    rarity: 'uncommon',
    type: 'armor',
    description:
      'Гибкая броня, сплетенная из нитей ночного эфира. Усиливает защиту.',
    value: 75,
    quantity: 1,
    bonuses: {
      defense: 4,
      maxHp: 10,
    },
  },
  outfit: {
    id: 'wanderers_attire',
    name: 'Наряд странника',
    rarity: 'common',
    type: 'outfit',
    description: 'Удобная одежда для долгих походов. Добавляет подвижность.',
    value: 30,
    quantity: 1,
    bonuses: {
      agility: 2,
    },
  },
  accessory: undefined,
};

const defaultInventorySeed: InventoryItem[] = [
  {
    id: 'healing_draught',
    name: 'Целебное зелье',
    rarity: 'common',
    type: 'consumable',
    description: 'Восстанавливает 30 здоровья. Сварено из трав леса Эирлинн.',
    value: 8,
    quantity: 2,
    stackable: true,
    effect: {
      type: 'heal',
      value: 30,
    },
  },
  {
    id: 'mystic_focus',
    name: 'Мистический фокус',
    rarity: 'uncommon',
    type: 'artifact',
    description: 'Сияющий кристалл, усиливающий восполнение маны на привале.',
    value: 35,
    quantity: 1,
  },
  {
    id: 'starlit_robe',
    name: 'Звёздный покров',
    rarity: 'rare',
    type: 'outfit',
    description: 'Лёгкая накидка, усиливающая связь с астральной стихией.',
    value: 110,
    quantity: 1,
    bonuses: {
      maxMana: 10,
      agility: 1,
    },
  },
  {
    id: 'crystal_earring',
    name: 'Кристальный оберег',
    rarity: 'uncommon',
    type: 'accessory',
    description: 'Амулет, поддерживающий плавный поток маны.',
    value: 60,
    quantity: 1,
    bonuses: {
      maxMana: 6,
    },
  },
  {
    id: 'ember_salve',
    name: 'Эмберовая мазь',
    rarity: 'common',
    type: 'consumable',
    description:
      'Ароматная мазь, ускоряющая регенерацию. Восстанавливает 18 здоровья.',
    value: 12,
    quantity: 1,
    stackable: true,
    effect: {
      type: 'heal',
      value: 18,
    },
  },
];

const MIN_AVAILABLE_QUESTS = 4;
const TARGET_AVAILABLE_QUESTS = 6;

const createInitialQuestBoard = (): Quest[] => {
  const idSet = new Set<string>();
  const starterActive = generateQuest({
    heroLevel: 1,
    travelDifficulty: 'story',
    status: 'active',
    categoryHint: 'hunt',
    existingIds: idSet,
  });
  const secondActive = generateQuest({
    heroLevel: 1,
    travelDifficulty: 'story',
    status: 'active',
    categoryHint: 'investigation',
    existingIds: idSet,
  });
  const availablePool = generateQuestBatch({
    count: TARGET_AVAILABLE_QUESTS,
    heroLevel: 1,
    travelDifficulty: 'story',
    existingIds: idSet,
  });
  return [starterActive, secondActive, ...availablePool];
};

const defaultDailyGoals: DailyGoal[] = [
  {
    id: 'daily_battles',
    title: 'Боевые учения',
    description: 'Победите трёх противников в схватках.',
    tag: 'battle',
    progress: 0,
    goal: 3,
    rewardXp: 80,
    rewardCoins: 25,
    completed: false,
    claimed: false,
  },
  {
    id: 'daily_explore',
    title: 'Следопыт',
    description: 'Завершите два приключенческих события.',
    tag: 'explore',
    progress: 0,
    goal: 2,
    rewardXp: 60,
    rewardCoins: 30,
    completed: false,
    claimed: false,
  },
  {
    id: 'daily_camp',
    title: 'Ритуалы лагеря',
    description: 'Используйте три действия отдыха или тренировки.',
    tag: 'training',
    progress: 0,
    goal: 3,
    rewardXp: 50,
    rewardCoins: 20,
    completed: false,
    claimed: false,
  },
];

const defaultAchievements: Achievement[] = [
  {
    id: 'first_blood',
    title: 'Первые шаги',
    description: 'Победите трёх противников в путешествии.',
    icon: 'trophy',
    unlocked: false,
  },
  {
    id: 'seasoned_traveler',
    title: 'Опытный проводник',
    description: 'Завершите пять событий или находок.',
    icon: 'map',
    unlocked: false,
  },
  {
    id: 'camp_master',
    title: 'Хозяин лагеря',
    description: 'Выполните пять тренировок или отдыхов.',
    icon: 'bonfire',
    unlocked: false,
  },
  {
    id: 'merchant_friend',
    title: 'Друг торговцев',
    description: 'Потратьте 400 монет в лавках.',
    icon: 'pricetag',
    unlocked: false,
  },
];

const difficultyModifiers: Record<
  TravelDifficulty,
  { xp: number; coins: number; damage: number }
> = {
  story: { xp: 1, coins: 1, damage: 1 },
  adventure: { xp: 1.15, coins: 1.1, damage: 1.05 },
  mythic: { xp: 1.35, coins: 1.25, damage: 1.2 },
};

const achievementConditions: Record<string, (state: HeroState) => boolean> = {
  first_blood: (state) => state.stats.battlesWon >= 3,
  seasoned_traveler: (state) =>
    state.stats.eventsCompleted + state.stats.treasuresOpened >= 5,
  camp_master: (state) => state.stats.trainingsCompleted >= 5,
  merchant_friend: (state) => state.stats.totalCoinsSpent >= 400,
};

const evaluateAchievements = (state: HeroState): Achievement[] =>
  state.achievements.map((achievement) => {
    const condition = achievementConditions[achievement.id];
    if (!condition || achievement.unlocked) {
      return achievement;
    }
    return condition(state) ? { ...achievement, unlocked: true } : achievement;
  });

const createDefaultHeroState = (): HeroState => ({
  name: 'Аэрин Лир',
  archetype: 'Арканный клинок',
  level: 1,
  xp: 0,
  xpForNext: 120,
  hp: 100,
  maxHp: 100,
  mana: 55,
  maxMana: 55,
  attack: 12,
  defense: 9,
  agility: 11,
  coins: 45,
  skillPoints: 0,
  relics: ['Сердце эфирного ветра'],
  inventory: defaultInventorySeed.map(cloneItem),
  quests: createInitialQuestBoard().map(cloneQuest),
  equipment: {
    weapon: defaultEquipmentSeed.weapon
      ? cloneItem(defaultEquipmentSeed.weapon)
      : undefined,
    armor: defaultEquipmentSeed.armor
      ? cloneItem(defaultEquipmentSeed.armor)
      : undefined,
    outfit: defaultEquipmentSeed.outfit
      ? cloneItem(defaultEquipmentSeed.outfit)
      : undefined,
    accessory: defaultEquipmentSeed.accessory
      ? cloneItem(defaultEquipmentSeed.accessory)
      : undefined,
  },
  travelDifficulty: 'story',
  dailyGoals: defaultDailyGoals.map((goal) => ({ ...goal })),
  achievements: defaultAchievements.map((achievement) => ({ ...achievement })),
  stats: {
    battlesWon: 0,
    eventsCompleted: 0,
    treasuresOpened: 0,
    purchasesMade: 0,
    trainingsCompleted: 0,
    dailyGoalsClaimed: 0,
    totalCoinsSpent: 0,
  },
  styleAccent: 'emerald',
  questBoardLastRefresh: new Date().toISOString(),
  questBoardRefreshCount: 0,
  lastUpdated: new Date().toISOString(),
});

const normalizeItem = (rawItem: any): InventoryItem => {
  const quantity =
    typeof rawItem?.quantity === 'number' && rawItem.quantity > 0
      ? rawItem.quantity
      : 1;
  return {
    id: rawItem?.id ?? `item-${Math.random().toString(16).slice(2, 7)}`,
    name: rawItem?.name ?? 'Неизвестный предмет',
    rarity: rawItem?.rarity ?? 'common',
    type: rawItem?.type ?? 'artifact',
    description:
      rawItem?.description ?? 'Таинственный предмет, требующий изучения.',
    value: typeof rawItem?.value === 'number' ? rawItem.value : 0,
    quantity,
    stackable: rawItem?.stackable ?? false,
    effect: rawItem?.effect ? { ...rawItem.effect } : undefined,
    bonuses: rawItem?.bonuses ? { ...rawItem.bonuses } : undefined,
  } as InventoryItem;
};

const normalizeQuest = (rawQuest: any): Quest => {
  const status = (rawQuest?.status as QuestStatus) ?? 'available';
  const goal =
    typeof rawQuest?.goal === 'number' && rawQuest.goal > 0 ? rawQuest.goal : 1;
  const progress =
    typeof rawQuest?.progress === 'number' ? rawQuest.progress : 0;
  const category = (rawQuest?.category as Quest['category']) ?? 'expedition';
  const rarity = (rawQuest?.rarity as Quest['rarity']) ?? 'routine';
  const urgency = (rawQuest?.urgency as Quest['urgency']) ?? 'calm';
  const location =
    typeof rawQuest?.location === 'string' &&
    rawQuest.location.trim().length > 0
      ? rawQuest.location
      : 'нераскрытая локация';
  const objectivesRaw = Array.isArray(rawQuest?.objectives)
    ? rawQuest.objectives.filter((entry: unknown) => typeof entry === 'string')
    : [];
  const objectives =
    objectivesRaw.length > 0
      ? objectivesRaw
      : ['Раскройте подробности задания и завершите цель.'];
  const narrativeHook =
    typeof rawQuest?.narrativeHook === 'string'
      ? rawQuest.narrativeHook
      : 'Герой чувствует, что это задание может изменить ход истории.';
  const generatedAt =
    typeof rawQuest?.generatedAt === 'string'
      ? rawQuest.generatedAt
      : new Date().toISOString();
  const expiresAt =
    typeof rawQuest?.expiresAt === 'string' ? rawQuest.expiresAt : undefined;
  const challengeRating =
    typeof rawQuest?.challengeRating === 'number' &&
    Number.isFinite(rawQuest.challengeRating)
      ? rawQuest.challengeRating
      : Math.max(1, Math.round(goal * 0.8));
  const faction =
    typeof rawQuest?.faction === 'string' ? rawQuest.faction : undefined;

  return {
    id: rawQuest?.id ?? `quest-${Math.random().toString(16).slice(2, 7)}`,
    title: rawQuest?.title ?? 'Неизвестное задание',
    description: rawQuest?.description ?? 'Таинственная задача ожидает героя.',
    status,
    progress,
    goal,
    tags: Array.isArray(rawQuest?.tags) ? rawQuest.tags : [],
    rewardXp: typeof rawQuest?.rewardXp === 'number' ? rawQuest.rewardXp : 0,
    rewardCoins:
      typeof rawQuest?.rewardCoins === 'number' ? rawQuest.rewardCoins : 0,
    rewardItem: rawQuest?.rewardItem
      ? normalizeItem(rawQuest.rewardItem)
      : undefined,
    category,
    rarity,
    urgency,
    location,
    narrativeHook,
    objectives,
    generatedAt,
    expiresAt,
    challengeRating,
    faction,
  };
};

const normalizeDailyGoal = (rawGoal: any): DailyGoal => ({
  id: rawGoal?.id ?? `daily-${Math.random().toString(16).slice(2, 7)}`,
  title: rawGoal?.title ?? 'Цель дня',
  description: rawGoal?.description ?? 'Задача ждёт уточнения.',
  tag: (rawGoal?.tag as DailyGoalTag) ?? 'battle',
  progress: typeof rawGoal?.progress === 'number' ? rawGoal.progress : 0,
  goal:
    typeof rawGoal?.goal === 'number' && rawGoal.goal > 0 ? rawGoal.goal : 1,
  rewardXp: typeof rawGoal?.rewardXp === 'number' ? rawGoal.rewardXp : 0,
  rewardCoins:
    typeof rawGoal?.rewardCoins === 'number' ? rawGoal.rewardCoins : 0,
  completed: Boolean(rawGoal?.completed),
  claimed: Boolean(rawGoal?.claimed),
});

const normalizeAchievement = (rawAchievement: any): Achievement => ({
  id: rawAchievement?.id ?? `achv-${Math.random().toString(16).slice(2, 7)}`,
  title: rawAchievement?.title ?? 'Неизвестный подвиг',
  description: rawAchievement?.description ?? 'Условия открытия ещё сокрыты.',
  icon: (rawAchievement?.icon as keyof typeof Ionicons.glyphMap) ?? 'trophy',
  unlocked: Boolean(rawAchievement?.unlocked),
});

const normalizeStats = (rawStats: any): HeroStats => ({
  battlesWon:
    typeof rawStats?.battlesWon === 'number' ? rawStats.battlesWon : 0,
  eventsCompleted:
    typeof rawStats?.eventsCompleted === 'number'
      ? rawStats.eventsCompleted
      : 0,
  treasuresOpened:
    typeof rawStats?.treasuresOpened === 'number'
      ? rawStats.treasuresOpened
      : 0,
  purchasesMade:
    typeof rawStats?.purchasesMade === 'number' ? rawStats.purchasesMade : 0,
  trainingsCompleted:
    typeof rawStats?.trainingsCompleted === 'number'
      ? rawStats.trainingsCompleted
      : 0,
  dailyGoalsClaimed:
    typeof rawStats?.dailyGoalsClaimed === 'number'
      ? rawStats.dailyGoalsClaimed
      : 0,
  totalCoinsSpent:
    typeof rawStats?.totalCoinsSpent === 'number'
      ? rawStats.totalCoinsSpent
      : 0,
});

const migrateHeroState = (rawState: any): HeroState => {
  const fallback = createDefaultHeroState();
  if (!rawState) {
    return fallback;
  }
  const inventory = Array.isArray(rawState.inventory)
    ? rawState.inventory.map((item: any) => normalizeItem(item))
    : fallback.inventory;
  const quests = Array.isArray(rawState.quests)
    ? rawState.quests.map((quest: any) => normalizeQuest(quest))
    : fallback.quests;
  const equipmentRaw = rawState.equipment ?? {};
  const equipment: Equipment = {
    weapon: equipmentRaw.weapon
      ? normalizeItem(equipmentRaw.weapon)
      : fallback.equipment.weapon,
    armor: equipmentRaw.armor
      ? normalizeItem(equipmentRaw.armor)
      : fallback.equipment.armor,
    outfit: equipmentRaw.outfit
      ? normalizeItem(equipmentRaw.outfit)
      : fallback.equipment.outfit,
    accessory: equipmentRaw.accessory
      ? normalizeItem(equipmentRaw.accessory)
      : fallback.equipment.accessory,
  };
  const dailyGoals = Array.isArray(rawState.dailyGoals)
    ? rawState.dailyGoals.map((goal: any) => normalizeDailyGoal(goal))
    : fallback.dailyGoals;
  const achievements = Array.isArray(rawState.achievements)
    ? rawState.achievements.map((ach: any) => normalizeAchievement(ach))
    : fallback.achievements;
  const stats = rawState.stats
    ? normalizeStats(rawState.stats)
    : fallback.stats;
  const travelDifficulty =
    (rawState.travelDifficulty as TravelDifficulty) ??
    fallback.travelDifficulty;
  const questBoardLastRefresh =
    typeof rawState.questBoardLastRefresh === 'string'
      ? rawState.questBoardLastRefresh
      : fallback.questBoardLastRefresh;
  const questBoardRefreshCount =
    typeof rawState.questBoardRefreshCount === 'number'
      ? rawState.questBoardRefreshCount
      : fallback.questBoardRefreshCount;

  return {
    ...fallback,
    ...rawState,
    inventory,
    quests,
    equipment,
    dailyGoals,
    achievements,
    stats,
    travelDifficulty,
    questBoardLastRefresh,
    questBoardRefreshCount,
    styleAccent: rawState.styleAccent ?? fallback.styleAccent,
    lastUpdated: rawState.lastUpdated ?? new Date().toISOString(),
  } as HeroState;
};

const adjustStatsWithItem = (
  stats: Pick<
    HeroState,
    'attack' | 'defense' | 'agility' | 'maxHp' | 'maxMana' | 'hp' | 'mana'
  >,
  item: InventoryItem | undefined,
  direction: 1 | -1,
) => {
  if (!item?.bonuses) {
    return stats;
  }
  const factor = direction === 1 ? 1 : -1;
  let { attack, defense, agility, maxHp, maxMana, hp, mana } = stats;

  if (item.bonuses.attack) {
    attack = Math.max(0, attack + item.bonuses.attack * factor);
  }
  if (item.bonuses.defense) {
    defense = Math.max(0, defense + item.bonuses.defense * factor);
  }
  if (item.bonuses.agility) {
    agility = Math.max(0, agility + item.bonuses.agility * factor);
  }
  if (item.bonuses.maxHp) {
    maxHp = Math.max(1, maxHp + item.bonuses.maxHp * factor);
    if (factor > 0) {
      hp = Math.min(maxHp, hp + Math.round(item.bonuses.maxHp / 2));
    } else {
      hp = Math.min(hp, maxHp);
    }
  }
  if (item.bonuses.maxMana) {
    maxMana = Math.max(0, maxMana + item.bonuses.maxMana * factor);
    if (factor > 0) {
      mana = Math.min(maxMana, mana + Math.round(item.bonuses.maxMana / 2));
    } else {
      mana = Math.min(mana, maxMana);
    }
  }

  return { attack, defense, agility, maxHp, maxMana, hp, mana };
};

const HeroContext = createContext<HeroContextValue | undefined>(undefined);

export const HeroProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [state, setState] = useState<HeroState>(createDefaultHeroState());
  const [isLoaded, setIsLoaded] = useState(false);
  const loadingRef = useRef(false);

  useEffect(() => {
    const loadHero = async () => {
      if (loadingRef.current) {
        return;
      }
      loadingRef.current = true;
      try {
        const raw = await AsyncStorage.getItem(HERO_STORAGE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          const migrated = migrateHeroState(parsed);
          setState(migrated);
        }
      } catch (error) {
        console.warn('Не удалось загрузить состояние героя', error);
      } finally {
        setIsLoaded(true);
        loadingRef.current = false;
      }
    };

    void loadHero();
  }, []);

  useEffect(() => {
    const persist = async () => {
      if (!isLoaded) {
        return;
      }
      try {
        await AsyncStorage.setItem(HERO_STORAGE_KEY, JSON.stringify(state));
      } catch (error) {
        console.warn('Не удалось сохранить состояние героя', error);
      }
    };

    void persist();
  }, [state, isLoaded]);

  const updateState = useCallback((updater: (prev: HeroState) => HeroState) => {
    setState((prev) => {
      const next = updater(prev);
      return {
        ...next,
        achievements: evaluateAchievements(next),
        lastUpdated: new Date().toISOString(),
      };
    });
  }, []);

  useEffect(() => {
    if (!isLoaded) {
      return;
    }
    updateState((prev) => {
      const { quests, added, refreshedAt } = rebuildQuestBoard(
        prev,
        prev.quests,
        {
          replaceAvailable: false,
        },
      );
      if (added === 0) {
        return prev;
      }
      return {
        ...prev,
        quests,
        questBoardLastRefresh: refreshedAt ?? prev.questBoardLastRefresh,
        questBoardRefreshCount: prev.questBoardRefreshCount + 1,
      };
    });
  }, [isLoaded, updateState]);

  const trackHeroStat = useCallback(
    (increments: Partial<Record<keyof HeroStats, number>>) => {
      if (!increments) {
        return;
      }
      updateState((prev) => {
        const nextStats: HeroStats = { ...prev.stats };
        (Object.keys(increments) as (keyof HeroStats)[]).forEach((key) => {
          const value = increments[key];
          if (typeof value === 'number' && Number.isFinite(value)) {
            nextStats[key] = Math.max(0, nextStats[key] + value);
          }
        });
        return {
          ...prev,
          stats: nextStats,
        };
      });
    },
    [updateState],
  );

  const updateDailyGoal = useCallback(
    (tag: DailyGoalTag, amount: number = 1) => {
      if (amount <= 0) {
        return;
      }
      updateState((prev) => {
        const goals = prev.dailyGoals.map((goal) => {
          if (goal.tag !== tag || goal.completed) {
            return goal;
          }
          const progress = Math.min(goal.goal, goal.progress + amount);
          return {
            ...goal,
            progress,
            completed: progress >= goal.goal,
          };
        });
        return {
          ...prev,
          dailyGoals: goals,
        };
      });
    },
    [updateState],
  );

  const resetDailyGoals = useCallback(() => {
    updateState((prev) => ({
      ...prev,
      dailyGoals: defaultDailyGoals.map((goal) => ({ ...goal })),
    }));
  }, [updateState]);

  const setTravelDifficulty = useCallback(
    (difficulty: TravelDifficulty) => {
      updateState((prev) => {
        if (prev.travelDifficulty === difficulty) {
          return prev;
        }
        const base = {
          ...prev,
          travelDifficulty: difficulty,
        };
        const { quests, refreshedAt } = rebuildQuestBoard(base, base.quests, {
          replaceAvailable: true,
        });
        return {
          ...base,
          quests,
          questBoardLastRefresh: refreshedAt ?? prev.questBoardLastRefresh,
          questBoardRefreshCount: prev.questBoardRefreshCount + 1,
        };
      });
    },
    [updateState],
  );

  const gainXp = useCallback(
    (amount: number) => {
      if (amount <= 0) {
        return;
      }
      updateState((prev) => {
        let xp = prev.xp + amount;
        let level = prev.level;
        let xpForNext = prev.xpForNext;
        let maxHp = prev.maxHp;
        let maxMana = prev.maxMana;
        let attack = prev.attack;
        let defense = prev.defense;
        let agility = prev.agility;
        let skillPoints = prev.skillPoints;
        let hp = prev.hp;
        let mana = prev.mana;

        while (xp >= xpForNext) {
          xp -= xpForNext;
          level += 1;
          xpForNext = Math.round(xpForNext * 1.35);
          maxHp += 14;
          maxMana += 9;
          attack += 3;
          defense += 2;
          agility += 2;
          skillPoints += 2;
          hp = Math.min(maxHp, hp + 10);
          mana = Math.min(maxMana, mana + 7);
        }

        return {
          ...prev,
          xp,
          level,
          xpForNext,
          maxHp,
          maxMana,
          attack,
          defense,
          agility,
          skillPoints,
          hp: Math.min(maxHp, hp),
          mana: Math.min(maxMana, mana),
        };
      });
    },
    [updateState],
  );

  const takeDamage = useCallback(
    (amount: number) => {
      if (amount <= 0) {
        return;
      }
      updateState((prev) => ({
        ...prev,
        hp: Math.max(0, prev.hp - amount),
      }));
    },
    [updateState],
  );

  const restoreHealth = useCallback(
    (amount: number) => {
      if (amount <= 0) {
        return;
      }
      updateState((prev) => ({
        ...prev,
        hp: Math.min(prev.maxHp, prev.hp + amount),
      }));
    },
    [updateState],
  );

  const spendMana = useCallback(
    (amount: number) => {
      if (amount <= 0) {
        return true;
      }
      let canSpend = true;
      updateState((prev) => {
        if (prev.mana < amount) {
          canSpend = false;
          return prev;
        }
        return {
          ...prev,
          mana: prev.mana - amount,
        };
      });
      return canSpend;
    },
    [updateState],
  );

  const restoreMana = useCallback(
    (amount: number) => {
      if (amount <= 0) {
        return;
      }
      updateState((prev) => ({
        ...prev,
        mana: Math.min(prev.maxMana, prev.mana + amount),
      }));
    },
    [updateState],
  );

  const addInventoryItem = useCallback(
    (item: InventoryItem) => {
      const normalized = cloneItem({ ...item, quantity: item.quantity ?? 1 });
      updateState((prev) => {
        const existingIndex = prev.inventory.findIndex(
          (invItem) => invItem.id === normalized.id,
        );
        if (existingIndex !== -1 && (normalized.stackable ?? false)) {
          const updatedInventory = [...prev.inventory];
          updatedInventory[existingIndex] = {
            ...updatedInventory[existingIndex],
            quantity:
              updatedInventory[existingIndex].quantity + normalized.quantity,
          };
          return {
            ...prev,
            inventory: updatedInventory,
          };
        }
        return {
          ...prev,
          inventory: [...prev.inventory, normalized],
        };
      });
    },
    [updateState],
  );

  const useConsumable = useCallback(
    (itemId: string) => {
      let message = 'Предмет не найден.';
      let success = false;
      updateState((prev) => {
        const inventory = [...prev.inventory];
        const index = inventory.findIndex((inv) => inv.id === itemId);
        if (index === -1) {
          return prev;
        }
        const item = inventory[index];
        if (item.type !== 'consumable') {
          message = 'Этот предмет нельзя использовать.';
          return prev;
        }
        let hp = prev.hp;
        let mana = prev.mana;
        let attack = prev.attack;
        let defense = prev.defense;
        let agility = prev.agility;

        if (item.effect) {
          if (item.effect.type === 'heal') {
            hp = Math.min(prev.maxHp, hp + item.effect.value);
            message = 'Здоровье восстановлено.';
          }
          if (item.effect.type === 'mana') {
            mana = Math.min(prev.maxMana, mana + item.effect.value);
            message = 'Мана восстановлена.';
          }
          if (item.effect.type === 'buff' && item.effect.stat) {
            const stat = item.effect.stat;
            if (stat === 'attack') {
              attack += item.effect.value;
            }
            if (stat === 'defense') {
              defense += item.effect.value;
            }
            if (stat === 'agility') {
              agility += item.effect.value;
            }
            message = 'Навык усилен.';
          }
        } else {
          message = 'Предмет использован.';
        }

        success = true;
        const newQuantity = item.quantity - 1;
        if (newQuantity <= 0) {
          inventory.splice(index, 1);
        } else {
          inventory[index] = {
            ...item,
            quantity: newQuantity,
          };
        }

        return {
          ...prev,
          inventory,
          hp,
          mana,
          attack,
          defense,
          agility,
        };
      });

      return { success, message };
    },
    [updateState],
  );

  const earnCoins = useCallback(
    (amount: number) => {
      if (amount <= 0) {
        return;
      }
      updateState((prev) => ({
        ...prev,
        coins: prev.coins + amount,
      }));
    },
    [updateState],
  );

  const claimDailyGoal = useCallback(
    (goalId: string) => {
      let success = false;
      let message = 'Цель пока не завершена.';
      let rewardXp = 0;
      let rewardCoins = 0;
      updateState((prev) => {
        const goals = prev.dailyGoals.map((goal) => {
          if (goal.id !== goalId) {
            return goal;
          }
          if (!goal.completed) {
            message = 'Цель ещё не завершена.';
            return goal;
          }
          if (goal.claimed) {
            message = 'Награда уже получена.';
            return goal;
          }
          success = true;
          rewardXp = goal.rewardXp;
          rewardCoins = goal.rewardCoins;
          message = 'Награда за дневную цель получена.';
          return {
            ...goal,
            claimed: true,
          };
        });
        if (!success) {
          return prev;
        }
        return {
          ...prev,
          dailyGoals: goals,
          stats: {
            ...prev.stats,
            dailyGoalsClaimed: prev.stats.dailyGoalsClaimed + 1,
          },
        };
      });
      if (success) {
        if (rewardXp > 0) {
          gainXp(rewardXp);
        }
        if (rewardCoins > 0) {
          earnCoins(rewardCoins);
        }
      }
      return { success, message };
    },
    [earnCoins, gainXp, updateState],
  );

  const spendCoins = useCallback(
    (amount: number) => {
      if (amount <= 0) {
        return true;
      }
      let isSuccessful = true;
      updateState((prev) => {
        if (prev.coins < amount) {
          isSuccessful = false;
          return prev;
        }
        return {
          ...prev,
          coins: prev.coins - amount,
          stats: {
            ...prev.stats,
            totalCoinsSpent: prev.stats.totalCoinsSpent + amount,
          },
        };
      });
      return isSuccessful;
    },
    [updateState],
  );

  const acceptQuest = useCallback(
    (questId: string) => {
      updateState((prev) => {
        let wasAccepted = false;
        const mutated = prev.quests.map((quest) => {
          if (quest.id === questId && quest.status === 'available') {
            wasAccepted = true;
            return {
              ...quest,
              status: 'active',
            };
          }
          return quest;
        });
        if (!wasAccepted) {
          return prev;
        }
        const { quests, added, refreshedAt } = rebuildQuestBoard(
          prev,
          mutated,
          {
            replaceAvailable: false,
          },
        );
        return {
          ...prev,
          quests,
          questBoardLastRefresh: refreshedAt ?? prev.questBoardLastRefresh,
          questBoardRefreshCount:
            added > 0
              ? prev.questBoardRefreshCount + 1
              : prev.questBoardRefreshCount,
        };
      });
    },
    [updateState],
  );

  const completeQuest = useCallback(
    (questId: string) => {
      let message = 'Квест пока не завершен.';
      let success = false;
      let rewardXp = 0;
      let rewardCoins = 0;
      let rewardItem: InventoryItem | undefined;

      updateState((prev) => {
        const mutated = prev.quests.map((quest) => {
          if (quest.id !== questId) {
            return quest;
          }
          if (quest.status === 'completed') {
            message = 'Награда уже получена.';
            return quest;
          }
          if (quest.status === 'active' && quest.progress >= quest.goal) {
            success = true;
            rewardXp = quest.rewardXp;
            rewardCoins = quest.rewardCoins;
            rewardItem = quest.rewardItem
              ? cloneItem({
                  ...quest.rewardItem,
                  quantity: quest.rewardItem.quantity ?? 1,
                })
              : undefined;
            message = 'Награда получена.';
            return {
              ...quest,
              status: 'completed',
            };
          }
          return quest;
        });

        if (!success) {
          return prev;
        }

        const { quests, added, refreshedAt } = rebuildQuestBoard(
          prev,
          mutated,
          {
            replaceAvailable: false,
          },
        );

        return {
          ...prev,
          quests,
          questBoardLastRefresh: refreshedAt ?? prev.questBoardLastRefresh,
          questBoardRefreshCount:
            added > 0
              ? prev.questBoardRefreshCount + 1
              : prev.questBoardRefreshCount,
        };
      });

      if (success) {
        if (rewardXp > 0) {
          gainXp(rewardXp);
        }
        if (rewardCoins > 0) {
          earnCoins(rewardCoins);
        }
        if (rewardItem) {
          addInventoryItem(rewardItem);
        }
      }

      return { success, message };
    },
    [addInventoryItem, earnCoins, gainXp, updateState],
  );

  const advanceQuest = useCallback(
    (tag: string, amount: number) => {
      if (amount <= 0) {
        return;
      }
      updateState((prev) => ({
        ...prev,
        quests: prev.quests.map((quest) => {
          if (quest.status === 'active' && quest.tags.includes(tag)) {
            const newProgress = Math.min(quest.goal, quest.progress + amount);
            return {
              ...quest,
              progress: newProgress,
            };
          }
          return quest;
        }),
      }));
    },
    [updateState],
  );

  const refreshQuestBoard = useCallback(
    (mode: 'full' | 'topUp' = 'full') => {
      let addedQuests = 0;
      updateState((prev) => {
        const { quests, added, refreshedAt } = rebuildQuestBoard(
          prev,
          prev.quests,
          {
            replaceAvailable: mode === 'full',
          },
        );
        addedQuests = added;
        if (mode === 'topUp' && added === 0) {
          return prev;
        }
        return {
          ...prev,
          quests,
          questBoardLastRefresh: refreshedAt ?? prev.questBoardLastRefresh,
          questBoardRefreshCount: prev.questBoardRefreshCount + 1,
        };
      });
      const message =
        mode === 'full'
          ? 'Гильдейский навигатор сплёл новую подборку поручений.'
          : addedQuests > 0
            ? 'Доска пополнена свежими заданиями.'
            : 'Все задания уже актуальны.';
      return { added: addedQuests, message };
    },
    [updateState],
  );

  const longRest = useCallback(() => {
    updateState((prev) => {
      const hasMysticFocus = prev.inventory.some(
        (item) => item.id === 'mystic_focus',
      );
      const manaRestoreBonus = hasMysticFocus ? 22 : 14;
      return {
        ...prev,
        hp: prev.maxHp,
        mana: Math.min(prev.maxMana, prev.mana + manaRestoreBonus),
        stats: {
          ...prev.stats,
          trainingsCompleted: prev.stats.trainingsCompleted + 1,
        },
      };
    });
    updateDailyGoal('training', 1);
  }, [updateDailyGoal, updateState]);

  const increaseAttribute = useCallback(
    (stat: AttributeStat) => {
      let message = 'Недостаточно очков навыков.';
      let success = false;
      updateState((prev) => {
        if (prev.skillPoints <= 0) {
          return prev;
        }
        success = true;
        message = 'Характеристика усилена.';
        const updates: Partial<HeroState> = {};
        if (stat === 'maxHp') {
          updates.maxHp = prev.maxHp + 10;
          updates.hp = Math.min(prev.maxHp + 10, prev.hp + 10);
        }
        if (stat === 'maxMana') {
          updates.maxMana = prev.maxMana + 8;
          updates.mana = Math.min(prev.maxMana + 8, prev.mана + 8);
        }
        if (stat === 'attack') {
          updates.attack = prev.attack + 2;
        }
        if (stat === 'defense') {
          updates.defense = prev.defense + 2;
        }
        if (stat === 'agility') {
          updates.agility = prev.agility + 2;
        }
        return {
          ...prev,
          ...updates,
          skillPoints: prev.skillPoints - 1,
        };
      });
      return { success, message };
    },
    [updateState],
  );

  const revive = useCallback(() => {
    updateState((prev) => ({
      ...prev,
      hp: Math.max(1, Math.round(prev.maxHp * 0.6)),
      mana: Math.round(prev.maxMana * 0.6),
      coins: Math.max(0, prev.coins - 15),
    }));
  }, [updateState]);

  const resetHero = useCallback(() => {
    const fresh = createDefaultHeroState();
    setState({
      ...fresh,
      lastUpdated: new Date().toISOString(),
    });
  }, []);

  const equipItem = useCallback(
    (itemId: string) => {
      let message = 'Предмет не найден.';
      let success = false;
      updateState((prev) => {
        const inventoryIndex = prev.inventory.findIndex(
          (invItem) => invItem.id === itemId,
        );
        if (inventoryIndex === -1) {
          return prev;
        }
        const item = prev.inventory[inventoryIndex];
        const slot: EquipmentSlot | null =
          item.type === 'weapon'
            ? 'weapon'
            : item.type === 'armor'
              ? 'armor'
              : item.type === 'outfit'
                ? 'outfit'
                : item.type === 'accessory'
                  ? 'accessory'
                  : null;
        if (!slot) {
          message = 'Этот предмет нельзя экипировать.';
          return prev;
        }

        const inventory = [...prev.inventory];
        if (item.quantity > 1 && (item.stackable ?? false)) {
          inventory[inventoryIndex] = {
            ...item,
            quantity: item.quantity - 1,
          };
        } else {
          inventory.splice(inventoryIndex, 1);
        }

        const statsBefore = {
          attack: prev.attack,
          defense: prev.defense,
          agility: prev.agility,
          maxHp: prev.maxHp,
          maxMana: prev.maxMana,
          hp: prev.hp,
          mana: prev.mana,
        };
        const withoutPrevious = adjustStatsWithItem(
          statsBefore,
          prev.equipment[slot],
          -1,
        );
        const withNew = adjustStatsWithItem(withoutPrevious, item, 1);

        const newEquipment: Equipment = {
          ...prev.equipment,
        };
        if (prev.equipment[slot]) {
          inventory.push({ ...prev.equipment[slot]!, quantity: 1 });
        }
        newEquipment[slot] = { ...item, quantity: 1 };

        message = `${item.name} экипирован.`;
        success = true;

        return {
          ...prev,
          ...withNew,
          inventory,
          equipment: newEquipment,
        };
      });

      return { success, message };
    },
    [updateState],
  );

  const unequipItem = useCallback(
    (slot: EquipmentSlot) => {
      let message = 'Предмет не экипирован.';
      let success = false;
      updateState((prev) => {
        const equippedItem = prev.equipment[slot];
        if (!equippedItem) {
          return prev;
        }
        const statsBefore = {
          attack: prev.attack,
          defense: prev.defense,
          agility: prev.agility,
          maxHp: prev.maxHp,
          maxMana: prev.maxMana,
          hp: prev.hp,
          mana: prev.mana,
        };
        const adjusted = adjustStatsWithItem(statsBefore, equippedItem, -1);
        const newEquipment: Equipment = {
          ...prev.equipment,
          [slot]: undefined,
        };
        const newInventory = [
          ...prev.inventory,
          { ...equippedItem, quantity: 1 },
        ];
        message = `${equippedItem.name} помещён в сумку.`;
        success = true;
        return {
          ...prev,
          ...adjusted,
          equipment: newEquipment,
          inventory: newInventory,
        };
      });
      return { success, message };
    },
    [updateState],
  );

  const purchaseItem = useCallback(
    (item: InventoryItem, cost: number) => {
      let message = 'Недостаточно монет.';
      let success = false;
      let purchasedItem: InventoryItem | undefined;
      updateState((prev) => {
        if (prev.coins < cost) {
          return prev;
        }
        success = true;
        purchasedItem = cloneItem({ ...item, quantity: item.quantity ?? 1 });
        message = `Приобретено: ${item.name}.`;
        return {
          ...prev,
          coins: prev.coins - cost,
          stats: {
            ...prev.stats,
            purchasesMade: prev.stats.purchasesMade + 1,
            totalCoinsSpent: prev.stats.totalCoinsSpent + cost,
          },
        };
      });
      if (success && purchasedItem) {
        addInventoryItem(purchasedItem);
        updateDailyGoal('shopping', 1);
      }
      return { success, message };
    },
    [addInventoryItem, updateDailyGoal, updateState],
  );

  const setStyleAccent = useCallback(
    (accent: HeroStyleAccent) => {
      updateState((prev) => ({
        ...prev,
        styleAccent: accent,
      }));
    },
    [updateState],
  );

  const trainDiscipline = useCallback(
    (stat: AttributeStat) => {
      const trainingCosts: Record<
        AttributeStat,
        { cost: number; label: string; increment: number }
      > = {
        attack: { cost: 60, label: 'Атака +1', increment: 1 },
        defense: { cost: 60, label: 'Защита +1', increment: 1 },
        agility: { cost: 60, label: 'Ловкость +1', increment: 1 },
        maxHp: { cost: 80, label: 'Здоровье +8', increment: 8 },
        maxMana: { cost: 80, label: 'Мана +6', increment: 6 },
      };

      const config = trainingCosts[stat];
      if (!config) {
        return { success: false, message: 'Неизвестная тренировка.' };
      }

      let success = false;
      let message = 'Недостаточно монет для тренировки.';

      updateState((prev) => {
        if (prev.coins < config.cost) {
          return prev;
        }
        success = true;
        message = `Тренировка завершена. ${config.label}`;

        let nextHp = prev.hp;
        let nextMaxHp = prev.maxHp;
        let nextMana = prev.mana;
        let nextMaxMana = prev.maxMana;
        let nextAttack = prev.attack;
        let nextDefense = prev.defense;
        let nextAgility = prev.agility;

        if (stat === 'attack') {
          nextAttack += config.increment;
        }
        if (stat === 'defense') {
          nextDefense += config.increment;
        }
        if (stat === 'agility') {
          nextAgility += config.increment;
        }
        if (stat === 'maxHp') {
          nextMaxHp += config.increment;
          nextHp = Math.min(nextMaxHp, nextHp + config.increment / 2);
        }
        if (stat === 'maxMana') {
          nextMaxMana += config.increment;
          nextMana = Math.min(nextMaxMana, nextMana + config.increment / 2);
        }

        return {
          ...prev,
          coins: prev.coins - config.cost,
          attack: nextAttack,
          defense: nextDefense,
          agility: nextAgility,
          maxHp: nextMaxHp,
          maxMana: nextMaxMana,
          hp: Math.min(nextMaxHp, nextHp),
          mana: Math.min(nextMaxMana, nextMana),
          stats: {
            ...prev.stats,
            trainingsCompleted: prev.stats.trainingsCompleted + 1,
            totalCoinsSpent: prev.stats.totalCoinsSpent + config.cost,
          },
        };
      });

      if (success) {
        gainXp(20);
        updateDailyGoal('training', 1);
      }

      return { success, message };
    },
    [gainXp, updateDailyGoal, updateState],
  );

  const value = useMemo<HeroContextValue>(
    () => ({
      state,
      isLoaded,
      gainXp,
      takeDamage,
      restoreHealth,
      spendMana,
      restoreMana,
      addInventoryItem,
      useConsumable,
      earnCoins,
      spendCoins,
      acceptQuest,
      completeQuest,
      advanceQuest,
      refreshQuestBoard,
      longRest,
      increaseAttribute,

      revive,
      resetHero,
      equipItem,
      unequipItem,
      purchaseItem,
      setStyleAccent,
      setTravelDifficulty,
      updateDailyGoal,
      claimDailyGoal,
      resetDailyGoals,
      trainDiscipline,
      trackHeroStat,
    }),
    [
      state,
      isLoaded,
      gainXp,
      takeDamage,
      restoreHealth,
      spendMana,
      restoreMana,
      addInventoryItem,
      useConsumable,
      earnCoins,
      spendCoins,
      acceptQuest,
      completeQuest,
      advanceQuest,
      refreshQuestBoard,
      longRest,
      increaseAttribute,

      revive,
      resetHero,
      equipItem,
      unequipItem,
      purchaseItem,
      setStyleAccent,
      setTravelDifficulty,
      updateDailyGoal,
      claimDailyGoal,
      resetDailyGoals,
      trainDiscipline,
      trackHeroStat,
    ],
  );

  return <HeroContext.Provider value={value}>{children}</HeroContext.Provider>;
};

export const useHero = () => {
  const context = useContext(HeroContext);
  if (!context) {
    throw new Error('useHero must be used within HeroProvider');
  }
  return context;
};

```

## File: /src/utils/accent.ts
```
import type { HeroStyleAccent } from '../context/HeroContext';

interface AccentTheme {
  border: string;
  surface: string;
  surfaceMuted: string;
  text: string;
  icon: string;
  glow: string;
}

export const accentPalette: Record<HeroStyleAccent, AccentTheme> = {
  emerald: {
    border: 'border-emerald-400/30',
    surface: 'bg-emerald-500/10',
    surfaceMuted: 'bg-emerald-500/5',
    text: 'text-emerald-200',
    icon: '#34d399',
    glow: 'shadow-lg',
  },
  sky: {
    border: 'border-sky-400/30',
    surface: 'bg-sky-500/10',
    surfaceMuted: 'bg-sky-500/5',
    text: 'text-sky-200',
    icon: '#38bdf8',
    glow: 'shadow-lg',
  },
  violet: {
    border: 'border-violet-400/30',
    surface: 'bg-violet-500/10',
    surfaceMuted: 'bg-violet-500/5',
    text: 'text-violet-200',
    icon: '#a855f7',
    glow: 'shadow-lg',
  },
  amber: {
    border: 'border-amber-400/30',
    surface: 'bg-amber-500/10',
    surfaceMuted: 'bg-amber-500/5',
    text: 'text-amber-200',
    icon: '#f59e0b',
    glow: 'shadow-lg',
  },
  crimson: {
    border: 'border-rose-400/30',
    surface: 'bg-rose-500/10',
    surfaceMuted: 'bg-rose-500/5',
    text: 'text-rose-200',
    icon: '#fb7185',
    glow: 'shadow-lg',
  },
};

```

## File: /src/utils/questGenerator.ts
```
import type {
  InventoryItem,
  Quest,
  QuestStatus,
  TravelDifficulty,
} from '../context/HeroContext';

export type QuestCategory =
  | 'hunt'
  | 'expedition'
  | 'ritual'
  | 'crafting'
  | 'investigation'
  | 'rescue'
  | 'diplomacy'
  | 'defense';

export type QuestRarity = 'routine' | 'notable' | 'grand' | 'legendary';

export type QuestUrgency = 'calm' | 'pressing' | 'critical';

interface WeightedValue<T> {
  value: T;
  weight: number;
}

interface QuestGenerationOptions {
  heroLevel: number;
  travelDifficulty: TravelDifficulty;
  existingIds?: Set<string>;
  status?: QuestStatus;
  categoryHint?: QuestCategory;
  urgencyBias?: QuestUrgency;
  rarityBias?: QuestRarity;
  seedOffset?: number;
}

interface QuestBatchOptions extends QuestGenerationOptions {
  count: number;
}

const randomFrom = <T,>(values: readonly T[]): T =>
  values[Math.floor(Math.random() * values.length)];

const pickWeighted = <T,>(candidates: readonly WeightedValue<T>[]): T => {
  const totalWeight = candidates.reduce((sum, item) => sum + item.weight, 0);
  let threshold = Math.random() * totalWeight;
  for (const candidate of candidates) {
    threshold -= candidate.weight;
    if (threshold <= 0) {
      return candidate.value;
    }
  }
  return candidates[candidates.length - 1].value;
};

const clamp = (value: number, min: number, max: number) =>
  Math.min(max, Math.max(min, value));

const ensureUniqueId = (existingIds?: Set<string>) => {
  let id = '';
  do {
    id = `quest-${Math.random().toString(16).slice(2, 10)}`;
  } while (existingIds?.has(id));
  existingIds?.add(id);
  return id;
};

const baseLocations = [
  'лес Тенестражей',
  'лока Лазурных осколков',
  'Катакомбы Священного Оракула',
  'риф Кристальной сирены',
  'плато Песни бурь',
  'сад Имперской луны',
  'пустошь Химерного пламени',
  'обитель Ясных холмов',
  'складки Астрального тумана',
  'чертоги Вечернего двора',
] as const;

const notableContacts = [
  'архивариус Мирэйн',
  'магистр Элдрен',
  'капитан стражи Вейр',
  'ведунья Кайлин',
  'исследователь Лоран',
  'пророчица Элир',
  'мастер-кузнец Ротхар',
  'хранительница хроник Сайли',
  'ткачиха чар Риин',
  'эмиссар Геликс',
] as const;

const factions = [
  'Астральный Орден',
  'Гильдия Странников',
  'Цветущий Конклат',
  'Хартия Охотников',
  'Синклит Светляков',
  'Ковен Ночного Пера',
  'Кольцо Златолистых',
  'Стражи Рубежа',
] as const;

const huntTargets = [
  {
    singular: 'пепельный василиск',
    plural: 'пепельных василисков',
    tags: ['battle', 'forest'] as const,
  },
  {
    singular: 'теневой раптор',
    plural: 'теневых рапторов',
    tags: ['battle', 'mystery'] as const,
  },
  {
    singular: 'кровавый геомант',
    plural: 'кровавых геомантов',
    tags: ['battle', 'ritual'] as const,
  },
  {
    singular: 'ледяной химер',
    plural: 'ледяных химеров',
    tags: ['battle', 'explore'] as const,
  },
];

const expeditionThemes = [
  {
    anomaly: 'сингулярность песочной руды',
    discovery: 'фрагменты зеркальной башни',
    tags: ['explore', 'mystery'] as const,
  },
  {
    anomaly: 'поющие руны фелморских врат',
    discovery: 'запечатанные голоса предтеч',
    tags: ['explore', 'lore'] as const,
  },
  {
    anomaly: 'ветровые картины эфирного шторма',
    discovery: 'журналы потерянных навигаторов',
    tags: ['explore', 'ritual'] as const,
  },
];

const ritualMotifs = [
  {
    rite: 'песнь семи кругов',
    consequence: 'откроется портал в теневой астрал',
    tags: ['ritual', 'mystery'] as const,
  },
  {
    rite: 'печать древнего самоцвета',
    consequence: 'начнёт угасать щит города',
    tags: ['ritual', 'lore'] as const,
  },
  {
    rite: 'обряд сопряжения стихий',
    consequence: 'пробудятся горные стражи',
    tags: ['ritual', 'gear'] as const,
  },
];

const craftingProjects = [
  {
    item: 'ариф-клинок кристальной трели',
    tags: ['craft', 'gear', 'style'] as const,
    output: 'чудесный клинок с резонансным звучанием',
  },
  {
    item: 'панцирь сумеречной грави',
    tags: ['craft', 'gear'] as const,
    output: 'укреплённая броня с эффектом хронополя',
  },
  {
    item: 'артефакт лунного прилива',
    tags: ['craft', 'ritual'] as const,
    output: 'талисман, впитывающий поток маны',
  },
];

const investigationClues = [
  {
    caseName: 'пропавшие эфирные скрижали',
    tags: ['mystery', 'lore'] as const,
    culprit: 'призрачные картографы',
  },
  {
    caseName: 'смещение звёздного маяка',
    tags: ['mystery', 'ritual'] as const,
    culprit: 'лунный синдикат',
  },
  {
    caseName: 'затерявшиеся хроники лирийцев',
    tags: ['mystery', 'explore'] as const,
    culprit: 'сборщик теней',
  },
];

const rescueScenarios = [
  {
    target: 'отряд юных эмпатов',
    hazard: 'лавина кристаллического льда',
    tags: ['battle', 'rescue'] as const,
  },
  {
    target: 'делегация звёздных адептов',
    hazard: 'пространственные тени',
    tags: ['diplomacy', 'mystery'] as const,
  },
  {
    target: 'караван утихших песков',
    hazard: 'пепельная буря и вороны-падальщики',
    tags: ['gear', 'rescue'] as const,
  },
];

const diplomacyThreads = [
  {
    dispute: 'разделение источника маны',
    tags: ['diplomacy', 'style'] as const,
  },
  {
    dispute: 'споры о древнем наследии',
    tags: ['diplomacy', 'lore'] as const,
  },
  {
    dispute: 'торговые пути через грозовые земли',
    tags: ['diplomacy', 'explore'] as const,
  },
];

const defenseBriefings = [
  {
    bastion: 'форпост Лазурной Гряды',
    threat: 'штурм шрапнельных големов',
    tags: ['battle', 'defense'] as const,
  },
  {
    bastion: 'деревня Огни Пеленора',
    threat: 'набег мороков из бездны',
    tags: ['battle', 'forest'] as const,
  },
  {
    bastion: 'маяк Мнемосин',
    threat: 'заражение астральной плесенью',
    tags: ['defense', 'mystery'] as const,
  },
];

const rarityWeights: readonly WeightedValue<QuestRarity>[] = [
  { value: 'routine', weight: 52 },
  { value: 'notable', weight: 32 },
  { value: 'grand', weight: 13 },
  { value: 'legendary', weight: 3 },
];

const urgencyWeights: readonly WeightedValue<QuestUrgency>[] = [
  { value: 'calm', weight: 58 },
  { value: 'pressing', weight: 32 },
  { value: 'critical', weight: 10 },
];

const rarityMultipliers: Record<QuestRarity, number> = {
  routine: 1,
  notable: 1.35,
  grand: 1.85,
  legendary: 2.5,
};

const urgencyTimeLimit: Partial<Record<QuestUrgency, [number, number]>> = {
  pressing: [24, 48],
  critical: [6, 18],
};

const travelDifficultyBonus: Record<TravelDifficulty, number> = {
  story: 1,
  adventure: 1.1,
  mythic: 1.28,
};

const travelCoinBonus: Record<TravelDifficulty, number> = {
  story: 1,
  adventure: 1.08,
  mythic: 1.22,
};

const formatTemplate = (
  template: string,
  context: Record<string, string | number>,
) => template.replace(/\{(\w+)\}/g, (_, key) => String(context[key] ?? key));

const createRewardItem = (
  category: QuestCategory,
  rarity: QuestRarity,
  existingIds?: Set<string>,
): InventoryItem | undefined => {
  const shouldDrop =
    rarity === 'legendary' ||
    rarity === 'grand' ||
    (rarity === 'notable' && Math.random() < 0.5) ||
    (category === 'crafting' && Math.random() < 0.65);

  if (!shouldDrop) {
    return undefined;
  }

  const id = (() => {
    let itemId = '';
    do {
      itemId = `reward-${Math.random().toString(16).slice(2, 10)}`;
    } while (existingIds?.has(itemId));
    existingIds?.add(itemId);
    return itemId;
  })();

  const rarityMap: Record<QuestRarity, InventoryItem['rarity']> = {
    routine: 'uncommon',
    notable: 'rare',
    grand: 'epic',
    legendary: 'legendary',
  };

  const valueBase = { routine: 60, notable: 120, grand: 220, legendary: 340 }[
    rarity
  ];
  const baseQuantity = rarity === 'routine' ? 1 : 1;

  if (category === 'hunt' || category === 'defense') {
    const names = [
      'Клинок громового барса',
      'Глефа янтарного дозорного',
      'Щит грозового гривера',
    ];
    return {
      id,
      name: randomFrom(names),
      rarity: rarityMap[rarity],
      type: 'weapon',
      description: 'Вооружение, насыщенное энергией последнего боя.',
      value: valueBase,
      quantity: baseQuantity,
      bonuses: {
        attack: rarity === 'legendary' ? 7 : rarity === 'grand' ? 5 : 3,
        agility: rarity === 'legendary' ? 3 : rarity === 'grand' ? 2 : 1,
      },
    };
  }

  if (category === 'crafting' || category === 'diplomacy') {
    const names = [
      'Атлас сияющих нитей',
      'Мантия калейдного арбитра',
      'Ленты небесной дипломатии',
    ];
    return {
      id,
      name: randomFrom(names),
      rarity: rarityMap[rarity],
      type: 'outfit',
      description: 'Редкий наряд, привлекающий уважение союзников.',
      value: valueBase,
      quantity: baseQuantity,
      bonuses: {
        agility: rarity === 'legendary' ? 4 : rarity === 'grand' ? 3 : 2,
        maxMana: rarity === 'legendary' ? 10 : rarity === 'grand' ? 8 : 6,
      },
    };
  }

  if (category === 'ritual' || category === 'investigation') {
    const names = [
      'Фокус туманного заката',
      'Сфера эйдетической памяти',
      'Хроникон сияющих шёпотов',
    ];
    return {
      id,
      name: randomFrom(names),
      rarity: rarityMap[rarity],
      type: 'artifact',
      description: 'Астральный артефакт, усиливающий магическую интуицию.',
      value: valueBase,
      quantity: baseQuantity,
      bonuses: {
        maxMana: rarity === 'legendary' ? 12 : rarity === 'grand' ? 10 : 6,
      },
    };
  }

  if (category === 'expedition' || category === 'rescue') {
    const names = [
      'Компас откровений',
      'Плащ путеводной искры',
      'Браслеты спасительного прилива',
    ];
    return {
      id,
      name: randomFrom(names),
      rarity: rarityMap[rarity],
      type: 'accessory',
      description: 'Талисман, оберегающий от ловушек и усиливающий реакцию.',
      value: valueBase,
      quantity: baseQuantity,
      bonuses: {
        agility: rarity === 'legendary' ? 4 : rarity === 'grand' ? 3 : 2,
        defense: rarity === 'legendary' ? 3 : rarity === 'grand' ? 2 : 1,
      },
    };
  }

  return undefined;
};

const deriveTagSet = (base: readonly string[], extra: readonly string[] = []) =>
  Array.from(new Set([...base, ...extra]));

const buildObjectives = (
  category: QuestCategory,
  context: Record<string, string | number>,
  goal: number,
) => {
  switch (category) {
    case 'hunt':
      return [
        formatTemplate(
          'Выследите следы {targetPlural} в окрестностях {location}',
          context,
        ),
        formatTemplate('Победите не менее {goal} {targetPlural}', {
          ...context,
          goal,
        }),
        formatTemplate('Допросите свидетелей и доложите {contact}', context),
      ];
    case 'expedition':
      return [
        formatTemplate('Отметьте границы явления: {anomaly}', context),
        formatTemplate(
          'Соберите образцы и задокументируйте {discovery}',
          context,
        ),
        formatTemplate('Передайте отчёт эмиссару {contact}', context),
      ];
    case 'ritual':
      return [
        formatTemplate('Удерживайте барьеры во время обряда {rite}', context),
        formatTemplate('Нейтрализуйте угрозы: {consequence}', context),
        formatTemplate('Стабилизируйте каналы и сообщите {contact}', context),
      ];
    case 'crafting':
      return [
        formatTemplate(
          'Соберите редкие материалы для проекта "{project}"',
          context,
        ),
        formatTemplate('Проведите {goal} цикл(ов) сплетения чар', {
          ...context,
          goal,
        }),
        formatTemplate('Представьте готовое изделие: {output}', context),
      ];
    case 'investigation':
      return [
        formatTemplate('Соберите показания по делу "{caseName}"', context),
        formatTemplate('Отследите причастность: {culprit}', context),
        formatTemplate('Запечатайте улики и доложите {contact}', context),
      ];
    case 'rescue':
      return [
        formatTemplate('Найдите и защитите {target}', context),
        formatTemplate('Обезвредьте угрозу: {hazard}', context),
        formatTemplate('Эвакуируйте выживших в безопасную зону', context),
      ];
    case 'diplomacy':
      return [
        formatTemplate('Подготовьте документы по спору: {dispute}', context),
        formatTemplate('Проведите {goal} раунд(а) переговоров', {
          ...context,
          goal,
        }),
        formatTemplate('Закрепите соглашение подписью {contact}', context),
      ];
    case 'defense':
      return [
        formatTemplate('Организуйте укрепления крепости {bastion}', context),
        formatTemplate('Отразите основную угрозу: {threat}', context),
        formatTemplate('Поддержите гарнизон {goal} волнами подкреплений', {
          ...context,
          goal,
        }),
      ];
    default:
      return [];
  }
};

const describeQuest = (
  category: QuestCategory,
  context: Record<string, string | number>,
  goal: number,
) => {
  switch (category) {
    case 'hunt':
      return formatTemplate(
        'В {location} объявился {targetSingular}. {contact} просит вас избавиться минимум от {goal} существ, чтобы обезопасить регион.',
        { ...context, goal },
      );
    case 'expedition':
      return formatTemplate(
        'На территории {location} обнаружена {anomaly}. Фракция {faction} поручает исследовать явление и вернуть {goal} ключевых находок.',
        { ...context, goal },
      );
    case 'ritual':
      return formatTemplate(
        'Ритуал "{rite}" в {location} выходит из-под контроля. Если его сорвать, {consequence}. Удержите процесс не менее {goal} кругов.',
        { ...context, goal },
      );
    case 'crafting':
      return formatTemplate(
        'Мастерская {contact} затеяла создание "{project}". Для завершения нужно выполнить {goal} циклов работы и представить {output}.',
        { ...context, goal },
      );
    case 'investigation':
      return formatTemplate(
        'Дело "{caseName}" зашло в тупик. Следы ведут в {location}, а всё указывает на {culprit}. Доведите расследование до конца.',
        context,
      );
    case 'rescue':
      return formatTemplate(
        '{target} оказались в беде поблизости от {location}. Вам предстоит вывести их с маршрута, преодолев: {hazard}.',
        context,
      );
    case 'diplomacy':
      return formatTemplate(
        'Фракции спорят о вопросе: {dispute}. Встреча состоится в {location}. Проведите переговоры и заключите мир.',
        context,
      );
    case 'defense':
      return formatTemplate(
        'Бастион {bastion} готовится отразить {threat}. Вам нужно удерживать линию обороны и отбить минимум {goal} волн нападения.',
        { ...context, goal },
      );
    default:
      return 'Загадочное поручение ожидает описания.';
  }
};

const narrativeHook = (
  category: QuestCategory,
  context: Record<string, string | number>,
) => {
  switch (category) {
    case 'hunt':
      return formatTemplate(
        'Следопыты сообщили, что {targetPlural} уже ранили двух патрульных. Отступать больше некуда.',
        context,
      );
    case 'expedition':
      return formatTemplate(
        'Оракулы уверяют: {anomaly} просуществует всего несколько суток. Нужно торопиться.',
        context,
      );
    case 'ritual':
      return formatTemplate(
        'Сбой обряда грозит региону — если {rite} не завершить, {consequence}.',
        context,
      );
    case 'crafting':
      return formatTemplate(
        'Лишь единицы способны соткать {project}. Работа обещает славу и уникальное изделие.',
        context,
      );
    case 'investigation':
      return formatTemplate(
        'Шёпот улиц говорит: {culprit} опять опередит стражу, если не вмешаться.',
        context,
      );
    case 'rescue':
      return formatTemplate(
        'Каждая минута промедления — смертельный риск для тех, кто ждёт помощи.',
        context,
      );
    case 'diplomacy':
      return formatTemplate(
        'Без капитана {contact} встреча закончится войной. Проявите твёрдость и такт.',
        context,
      );
    case 'defense':
      return formatTemplate(
        'Гарнизон держится из последних сил, но {threat} вот-вот прорвёт оборону.',
        context,
      );
    default:
      return 'Судьба региона зависит от исхода задания.';
  }
};

const pickCategory = (hint?: QuestCategory): QuestCategory => {
  if (hint) {
    return hint;
  }
  const categories: QuestCategory[] = [
    'hunt',
    'expedition',
    'ritual',
    'crafting',
    'investigation',
    'rescue',
    'diplomacy',
    'defense',
  ];
  return randomFrom(categories);
};

export const generateQuest = (options: QuestGenerationOptions): Quest => {
  const {
    heroLevel,
    travelDifficulty,
    existingIds,
    status = 'available',
    categoryHint,
    urgencyBias,
    rarityBias,
    seedOffset = 0,
  } = options;

  const category = pickCategory(categoryHint);
  const rarity = rarityBias ?? pickWeighted(rarityWeights);
  const urgency = urgencyBias ?? pickWeighted(urgencyWeights);

  const baseGoalByCategory: Record<QuestCategory, [number, number]> = {
    hunt: [3, 6],
    expedition: [2, 4],
    ritual: [3, 5],
    crafting: [2, 5],
    investigation: [2, 4],
    rescue: [1, 3],
    diplomacy: [2, 3],
    defense: [3, 5],
  };

  const goalRange = baseGoalByCategory[category];
  const goal = clamp(
    Math.round(
      goalRange[0] +
        Math.random() * (goalRange[1] - goalRange[0] + seedOffset * 0.15),
    ),
    goalRange[0],
    goalRange[1] + seedOffset,
  );

  const location = randomFrom(baseLocations);
  const contact = randomFrom(notableContacts);
  const faction = randomFrom(factions);

  const context: Record<string, string | number> = {
    location,
    contact,
    faction,
  };

  let tags: string[] = [];

  switch (category) {
    case 'hunt': {
      const target = randomFrom(huntTargets);
      Object.assign(context, {
        targetSingular: target.singular,
        targetPlural: target.plural,
      });
      tags = deriveTagSet(target.tags as unknown as string[], ['battle']);
      break;
    }
    case 'expedition': {
      const theme = randomFrom(expeditionThemes);
      Object.assign(context, {
        anomaly: theme.anomaly,
        discovery: theme.discovery,
      });
      tags = deriveTagSet(theme.tags as unknown as string[], ['explore']);
      break;
    }
    case 'ritual': {
      const motif = randomFrom(ritualMotifs);
      Object.assign(context, {
        rite: motif.rite,
        consequence: motif.consequence,
      });
      tags = deriveTagSet(motif.tags as unknown as string[], ['ritual']);
      break;
    }
    case 'crafting': {
      const project = randomFrom(craftingProjects);
      Object.assign(context, {
        project: project.item,
        output: project.output,
      });
      tags = deriveTagSet(project.tags as unknown as string[], ['craft']);
      break;
    }
    case 'investigation': {
      const clue = randomFrom(investigationClues);
      Object.assign(context, {
        caseName: clue.caseName,
        culprit: clue.culprit,
      });
      tags = deriveTagSet(clue.tags as unknown as string[], ['mystery']);
      break;
    }
    case 'rescue': {
      const scenario = randomFrom(rescueScenarios);
      Object.assign(context, {
        target: scenario.target,
        hazard: scenario.hazard,
      });
      tags = deriveTagSet(scenario.tags as unknown as string[], ['rescue']);
      break;
    }
    case 'diplomacy': {
      const thread = randomFrom(diplomacyThreads);
      Object.assign(context, {
        dispute: thread.dispute,
      });
      tags = deriveTagSet(thread.tags as unknown as string[], ['diplomacy']);
      break;
    }
    case 'defense': {
      const briefing = randomFrom(defenseBriefings);
      Object.assign(context, {
        bastion: briefing.bastion,
        threat: briefing.threat,
      });
      tags = deriveTagSet(briefing.tags as unknown as string[], ['defense']);
      break;
    }
    default:
      tags = ['explore'];
  }

  const questId = ensureUniqueId(existingIds);
  const rewardXpBase = 80 + heroLevel * 18;
  const rewardCoinsBase = 40 + heroLevel * 12;

  const xp = Math.round(
    rewardXpBase *
      rarityMultipliers[rarity] *
      travelDifficultyBonus[travelDifficulty],
  );
  const coins = Math.round(
    rewardCoinsBase *
      rarityMultipliers[rarity] *
      travelCoinBonus[travelDifficulty] *
      0.72,
  );

  const challengeRating = clamp(
    Math.round(heroLevel / 2 + rarityMultipliers[rarity] * 1.6 + goal * 0.4),
    1,
    9,
  );

  const expiresAtRange = urgencyTimeLimit[urgency];
  let expiresAt: string | undefined;
  if (expiresAtRange) {
    const [minHours, maxHours] = expiresAtRange;
    const hours = clamp(
      minHours + Math.random() * (maxHours - minHours + seedOffset * 0.1),
      minHours,
      maxHours + seedOffset * 0.3,
    );
    const expirationDate = new Date();
    expirationDate.setHours(expirationDate.getHours() + Math.round(hours));
    expiresAt = expirationDate.toISOString();
  }

  const objectives = buildObjectives(category, context, goal);
  const description = describeQuest(category, context, goal);
  const hook = narrativeHook(category, context);
  const rewardItem = createRewardItem(category, rarity, existingIds);

  const quest: Quest = {
    id: questId,
    title: (() => {
      switch (category) {
        case 'hunt':
          return formatTemplate('Охота на {targetPlural}', context);
        case 'expedition':
          return formatTemplate('Экспедиция: {anomaly}', context);
        case 'ritual':
          return formatTemplate('Стабилизировать {rite}', context);
        case 'crafting':
          return formatTemplate('Создание "{project}"', context);
        case 'investigation':
          return formatTemplate('Расследование: {caseName}', context);
        case 'rescue':
          return formatTemplate('Спасти {target}', context);
        case 'diplomacy':
          return formatTemplate('Мандат переговорщика: {dispute}', context);
        case 'defense':
          return formatTemplate('Оборона {bastion}', context);
        default:
          return 'Загадочное поручение';
      }
    })(),
    description,
    status,
    progress: 0,
    goal,
    tags,
    rewardXp: xp,
    rewardCoins: coins,
    rewardItem,
    category,
    rarity,
    urgency,
    location,
    narrativeHook: hook,
    objectives,
    generatedAt: new Date().toISOString(),
    expiresAt,
    challengeRating,
    faction,
  };

  return quest;
};

export const generateQuestBatch = (options: QuestBatchOptions): Quest[] => {
  const { count, existingIds, ...rest } = options;
  const ids = existingIds ?? new Set<string>();
  const result: Quest[] = [];
  for (let index = 0; index < count; index += 1) {
    result.push(
      generateQuest({
        ...rest,
        existingIds: ids,
        seedOffset: (rest.seedOffset ?? 0) + index,
      }),
    );
  }
  return result;
};

```

